from django import formsfrom datetime import timedeltafrom workalendar.europe import Russiafrom django.contrib.auth.models import Userfrom .models import OvertimeRequest, Employee, Positionclass EmployeeProfileForm(forms.ModelForm):    class Meta:        model = Employee        fields = ['full_name', 'department', 'manager1']  # ← Убрали 'position'        widgets = {            'full_name': forms.TextInput(attrs={'class': 'w-full px-4 py-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500'}),            'department': forms.TextInput(attrs={'class': 'w-full px-4 py-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500'}),            'manager1': forms.Select(attrs={'class': 'w-full px-4 py-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500'}),        }    def __init__(self, *args, **kwargs):        super().__init__(*args, **kwargs)        # Ограничим выбор руководителя только сотрудниками с ролью "Руководитель"        self.fields['manager1'].queryset = Employee.objects.filter(            position__name__icontains='Руководитель'        ).exclude(id=self.instance.id)  # исключаем самого себяclass OvertimeRequestForm(forms.ModelForm):    class Meta:        model = OvertimeRequest        fields = ['start_datetime', 'end_datetime', 'reason', 'justification']        widgets = {            'start_datetime': forms.DateTimeInput(attrs={'type': 'datetime-local'}),            'end_datetime': forms.DateTimeInput(attrs={'type': 'datetime-local'}),        }    def clean_start_datetime(self):        start = self.cleaned_data['start_datetime']        cal = Russia()        if cal.is_working_day(start.date()):            raise forms.ValidationError("Переработки в будние дни не оформляются.")        return start    def clean_end_datetime(self):        end = self.cleaned_data['end_datetime']        cal = Russia()        if cal.is_working_day(end.date()):            raise forms.ValidationError("Переработки в будние дни не оформляются.")        return end    def clean(self):        cleaned_data = super().clean()        start = cleaned_data.get('start_datetime')        end = cleaned_data.get('end_datetime')        if start and end:            if start >= end:                raise forms.ValidationError("Дата окончания должна быть позже даты начала.")            current = start.date()            end_date = end.date()            cal = Russia()            while current <= end_date:                if cal.is_working_day(current):                    raise forms.ValidationError(f"Переработка не может охватывать будни. Нарушение: {current}")                current += timedelta(days=1)        return cleaned_dataclass EmployeeRegistrationForm(forms.ModelForm):    username = forms.CharField(max_length=150, help_text="Имя пользователя для входа")    password = forms.CharField(widget=forms.PasswordInput(), help_text="Пароль")    password_confirm = forms.CharField(widget=forms.PasswordInput(), help_text="Подтвердите пароль")    email = forms.EmailField(help_text="Email для связи")    class Meta:        model = Employee        fields = ['full_name', 'department', 'manager1', 'position']    def __init__(self, *args, **kwargs):        super().__init__(*args, **kwargs)        # Ограничиваем выбор руководителя        self.fields['manager1'].queryset = Employee.objects.all()        # Устанавливаем queryset для должностей        self.fields['position'].queryset = Position.objects.all()    def clean_password_confirm(self):        password = self.cleaned_data.get('password')        password_confirm = self.cleaned_data.get('password_confirm')        if password and password_confirm and password != password_confirm:            raise forms.ValidationError("Пароли не совпадают")        return password_confirm    def clean_email(self):        email = self.cleaned_data.get('email')        if User.objects.filter(email=email).exists():            raise forms.ValidationError("Пользователь с таким email уже существует")        if Employee.objects.filter(email=email).exists():            raise forms.ValidationError("Сотрудник с таким email уже существует")        return email    def save(self, commit=True):        # Создаем пользователя        user = User.objects.create_user(            username=self.cleaned_data['username'],            email=self.cleaned_data['email'],            password=self.cleaned_data['password']        )        # Создаем сотрудника        employee = super().save(commit=False)        employee.email = user.email        if commit:            employee.save()        return employee