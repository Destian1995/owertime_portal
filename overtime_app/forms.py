from django import formsfrom datetime import timedelta, datetimefrom workalendar.europe import Russiafrom django.contrib.auth.models import Userfrom .models import OvertimeRequest, Employee, Positionclass EmployeeProfileForm(forms.ModelForm):    class Meta:        model = Employee        fields = ['full_name', 'department', 'manager1']  # ← Убрали 'position'        widgets = {            'full_name': forms.TextInput(attrs={'class': 'w-full px-4 py-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500'}),            'department': forms.TextInput(attrs={'class': 'w-full px-4 py-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500'}),            'manager1': forms.Select(attrs={'class': 'w-full px-4 py-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500'}),        }    def __init__(self, *args, **kwargs):        super().__init__(*args, **kwargs)        # Ограничим выбор руководителя только сотрудниками с ролью "Руководитель"        self.fields['manager1'].queryset = Employee.objects.filter(            position__name__icontains='Руководитель'        ).exclude(id=self.instance.id)  # исключаем самого себяclass OvertimeRequestForm(forms.ModelForm):    class Meta:        model = OvertimeRequest        fields = ['start_datetime', 'end_datetime', 'reason', 'justification', 'attachment'] # Добавлено 'attachment'        widgets = {            'start_datetime': forms.TextInput(attrs={                'class': 'flatpickr-datetime',                'placeholder': 'ДД.ММ.ГГГГ ЧЧ:ММ'            }),            'end_datetime': forms.TextInput(attrs={                'class': 'flatpickr-datetime',                'placeholder': 'ДД.ММ.ГГГГ ЧЧ:ММ'            }),            # Добавим простой виджет для файла            'attachment': forms.FileInput(attrs={'class': 'border border-gray-300 rounded-lg px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent'}),        }    def _parse_datetime_field(self, value_str):        """Вспомогательный метод для парсинга строки даты."""        if isinstance(value_str, datetime):            return value_str        if isinstance(value_str, str):            try:                return datetime.strptime(value_str, '%Y-%m-%d %H:%M')            except ValueError:                raise forms.ValidationError("Неверный формат даты и времени. Используйте ГГГГ-ММ-ДД ЧЧ:ММ.")        raise forms.ValidationError("Неверный тип данных для даты и времени.")    def clean_start_datetime(self):        start_value = self.cleaned_data['start_datetime']        start = self._parse_datetime_field(start_value)        cal = Russia()        if cal.is_working_day(start.date()):            raise forms.ValidationError("Переработки в будние дни не оформляются.")        return start    def clean_end_datetime(self):        end_value = self.cleaned_data['end_datetime']        end = self._parse_datetime_field(end_value)        cal = Russia()        if cal.is_working_day(end.date()):            raise forms.ValidationError("Переработки в будние дни не оформляются.")        return end    def clean(self):        cleaned_data = super().clean()        start = cleaned_data.get('start_datetime')        end = cleaned_data.get('end_datetime')        if start and end:            if start >= end:                raise forms.ValidationError("Дата окончания должна быть позже даты начала.")            current = start.date()            end_date = end.date()            cal = Russia()            while current <= end_date:                if cal.is_working_day(current):                    raise forms.ValidationError(f"Переработка не может охватывать будни. Нарушение: {current}")                current += timedelta(days=1)        return cleaned_dataclass ResetPasswordForm(forms.Form):    username = forms.CharField(max_length=150, label='Логин')    new_password1 = forms.CharField(widget=forms.PasswordInput(), label='Новый пароль')    new_password2 = forms.CharField(widget=forms.PasswordInput(), label='Повторите пароль')    def clean_username(self):        username = self.cleaned_data.get('username')        if not User.objects.filter(username=username).exists():            raise forms.ValidationError('Пользователь с таким логином не существует.')        return username    def clean(self):        cleaned_data = super().clean()        password1 = cleaned_data.get('new_password1')        password2 = cleaned_data.get('new_password2')        if password1 and password2 and password1 != password2:            raise forms.ValidationError('Пароли не совпадают.')        return cleaned_data