from django.db import modelsfrom django.contrib.auth.models import Userimport osfrom django.urls import reverseclass Position(models.Model):    name = models.CharField(max_length=200, unique=True)    class Meta:        verbose_name = 'Должность'        verbose_name_plural = 'Должности'    def __str__(self):        return self.nameclass Holiday(models.Model):    date = models.DateField(unique=True)    is_holiday = models.BooleanField(default=True)    class Meta:        verbose_name = 'Праздничный день'        verbose_name_plural = 'Праздничные дни'    def __str__(self):        return f"{self.date} ({'Выходной' if self.is_holiday else 'Рабочий'})"class Employee(models.Model):    full_name = models.CharField(max_length=200, verbose_name='ФИО')    department = models.CharField(max_length=200, blank=True, verbose_name='Отдел')    manager1 = models.ForeignKey('self', on_delete=models.SET_NULL, null=True, blank=True, related_name='subordinates1', verbose_name='Руководитель 1')    manager2 = models.ForeignKey('self', on_delete=models.SET_NULL, null=True, blank=True, related_name='subordinates2', verbose_name='Руководитель 2')    email = models.EmailField(unique=True, verbose_name='Email')    position = models.ForeignKey(Position, on_delete=models.SET_NULL, null=True, blank=True, verbose_name='Должность')    class Meta:        verbose_name = 'Сотрудник'        verbose_name_plural = 'Сотрудники'    def __str__(self):        return self.full_name    @property    def is_manager(self):        # Определяем роль по названию должности        # Проверяем, что position существует И его name не пустой (не None и не '')        if self.position and self.position.name:            return self.position.name.lower() in ['руководитель', 'менеджер', 'начальник']        return Falseclass OvertimeRequest(models.Model):    STATUS_CHOICES = [        ('pending', 'На согласовании'),        ('approved', 'Согласовано'),        ('rejected', 'Отклонено'),    ]    REASON_CHOICES = [        ('holiday', 'Работа в выходной и праздничный день'),        ('incident', 'Работы по устранению инцидентов'),        ('maintenance', 'Регламентные работы по обслуживанию системы'),    ]    employee = models.ForeignKey("Employee", on_delete=models.CASCADE, verbose_name="Сотрудник")    created_at = models.DateTimeField(auto_now_add=True, verbose_name="Дата создания")    start_datetime = models.DateTimeField(verbose_name="Дата и время начала")    end_datetime = models.DateTimeField(verbose_name="Дата и время окончания")    reason = models.CharField(max_length=200, choices=REASON_CHOICES, verbose_name="Причина")    justification = models.TextField(verbose_name="Обоснование")    status = models.CharField(max_length=20, choices=STATUS_CHOICES, default="pending", verbose_name="Статус")    hours = models.FloatField(editable=False, verbose_name="Количество часов")    attachment = models.FileField(upload_to="overtime_attachments/", blank=True, null=True, verbose_name="Прикрепленный файл")    class Meta:        verbose_name = "Заявка на переработку"        verbose_name_plural = "Заявки на переработку"    def save(self, *args, **kwargs):        duration = self.end_datetime - self.start_datetime        self.hours = duration.total_seconds() / 3600        super().save(*args, **kwargs)    def get_attachment_view_url(self):        """Возвращает URL, который откроет файл с правильной кодировкой."""        if self.attachment:            filename = os.path.basename(self.attachment.name)            return reverse("serve_text_file", args=[filename])        return None    def __str__(self):        return f"Заявка #{self.id} от {self.employee.full_name}"import secretsfrom django.utils import timezoneclass ApprovalToken(models.Model):    token = models.CharField(max_length=64, unique=True)    request = models.ForeignKey(OvertimeRequest, on_delete=models.CASCADE)    approver = models.ForeignKey(Employee, on_delete=models.CASCADE)    created_at = models.DateTimeField(auto_now_add=True)    expires_at = models.DateTimeField()    used = models.BooleanField(default=False)    @classmethod    def create_token(cls, request, approver):        token = secrets.token_urlsafe(32)        expires_at = timezone.now() + timezone.timedelta(days=7)  # Токен живёт 7 дней        return cls.objects.create(            token=token,            request=request,            approver=approver,            expires_at=expires_at        )    def is_valid(self):        return not self.used and timezone.now() < self.expires_atclass ApprovalLog(models.Model):    DECISION_CHOICES = [        ('approved', 'Согласовано'),        ('rejected', 'Не согласовано'),    ]    request = models.ForeignKey(OvertimeRequest, on_delete=models.CASCADE, related_name='approvals', verbose_name='Заявка')    approver = models.ForeignKey(Employee, on_delete=models.CASCADE, verbose_name='Согласующий')    decision = models.CharField(max_length=20, choices=DECISION_CHOICES, verbose_name='Решение')    comment = models.TextField(blank=True, verbose_name='Комментарий')    timestamp = models.DateTimeField(auto_now_add=True, verbose_name='Дата и время')    class Meta:        verbose_name = 'Запись согласования'        verbose_name_plural = 'Записи согласования'    def __str__(self):        return f"{self.decision} - {self.approver.full_name} ({self.timestamp})"