from django.shortcuts import render, get_object_or_404, redirectfrom django.contrib import messagesfrom django.core.mail import send_mailfrom django.contrib.auth.decorators import login_requiredfrom django.contrib.auth import login, authenticatefrom django.http import HttpResponsefrom docx import Documentfrom django.urls import reversefrom django.core.mail import EmailMultiAlternativesfrom datetime import datetimefrom django.utils import timezonefrom .models import OvertimeRequest, Employee, ApprovalLog, Position, ApprovalTokenfrom .forms import OvertimeRequestForm, EmployeeRegistrationForm, EmployeeProfileFormfrom django.contrib.auth.views import LogoutView as DjangoLogoutViewclass LogoutView(DjangoLogoutView):    http_method_names = ['get', 'post']# Исправленная функция process_approvaldef process_approval(req, approver, decision, comment):    """    Обрабатывает решение по заявке: создает запись в логе, обновляет статус, отправляет уведомление.    """    # Создаем запись согласования    ApprovalLog.objects.create(        request=req,        approver=approver,        decision=decision,        comment=comment    )    # Обновляем статус    if decision == 'approved':        req.status = 'approved'    elif decision == 'rework':        req.status = 'rework'    elif decision == 'rejected':        req.status = 'rejected'    req.save()    # Отправляем уведомление сотруднику    send_mail(        subject=f'Заявка #{req.id}: {req.get_status_display()}',        message=f'Ваша заявка #{req.id} была {"согласована" if decision == "approved" else "отправлена на доработку" if decision == "rework" else "отклонена"}. Комментарий: {comment}',        from_email=None,        recipient_list=[req.employee.email],    )    # Помечаем токен как использованный    try:        token_obj = ApprovalToken.objects.get(request=req, approver=approver, used=False)        token_obj.used = True        token_obj.save()    except ApprovalToken.DoesNotExist:        # Можно добавить логирование        pass# Исправленная функция approve_via_email (проверка токена и завершение логики)@login_requireddef approve_via_email(request, req_id):    """    Обрабатывает согласование/отклонение заявки через email-ссылку.    """    req = get_object_or_404(OvertimeRequest, id=req_id)    token = request.GET.get('token')    decision = request.GET.get('decision')    if decision not in ['approved', 'rework', 'rejected']:        messages.error(request, 'Неверное действие.')        return redirect('overtime_app:dashboard')    # Проверка токена    try:        token_obj = ApprovalToken.objects.get(token=token, request=req)        # Проверка валидности токена        if token_obj.used or token_obj.expires_at < timezone.now():            messages.error(request, 'Ссылка недействительна или истекла.')            return redirect('overtime_app:dashboard')    except ApprovalToken.DoesNotExist:        messages.error(request, 'Неверная ссылка.')        return redirect('overtime_app:dashboard')    # Получаем текущего пользователя (руководителя)    try:        approver = Employee.objects.get(email=request.user.email)    except Employee.DoesNotExist:        messages.error(request, 'Ваш профиль сотрудника не найден.')        return redirect('overtime_app:dashboard')    # Проверяем, является ли текущий пользователь правильным согласующим    if token_obj.approver != approver:        messages.error(request, 'Недостаточно прав для согласования.')        return redirect('overtime_app:dashboard')    # Обработка решения    comment = request.GET.get('comment', '')    process_approval(req, approver, decision, comment)    messages.success(request, f'Заявка #{req.id} была {"согласована" if decision == "approved" else "отправлена на доработку" if decision == "rework" else "отклонена"}.')    return redirect('overtime_app:dashboard')# Исправленная функция approve_request - теперь обрабатывает POST-запросы из веб-интерфейса@login_requireddef approve_request(request, req_id):    """    Обрабатывает согласование/отклонение заявки через веб-интерфейс.    """    if request.method != 'POST':        return redirect('overtime_app:dashboard')    req = get_object_or_404(OvertimeRequest, id=req_id)    # Получаем текущего пользователя (руководителя)    try:        approver = Employee.objects.get(email=request.user.email)    except Employee.DoesNotExist:        messages.error(request, 'Ваш профиль сотрудника не найден.')        return redirect('overtime_app:dashboard')    # Проверяем, является ли текущий пользователь правильным согласующим    # (например, manager1). Можно расширить логику для manager2.    if req.employee.manager1 != approver:        messages.error(request, 'У вас нет прав для согласования этой заявки.')        return redirect('overtime_app:dashboard')    decision = request.POST.get('decision')    if decision not in ['approved', 'rework', 'rejected']:        messages.error(request, 'Неверное действие.')        return redirect('overtime_app:dashboard')    comment = request.POST.get('comment', '')    # Используем общую функцию обработки    process_approval(req, approver, decision, comment)    messages.success(request, f'Заявка #{req.id} была {"согласована" if decision == "approved" else "отправлена на доработку" if decision == "rework" else "отклонена"}.')    return redirect('overtime_app:dashboard')@login_requireddef export_requests_word(request):    """    Экспортирует отфильтрованные заявки в документ Word.    """    employee = Employee.objects.get(email=request.user.email)    is_manager = employee.is_manager    # Начальный queryset    if is_manager:        requests = OvertimeRequest.objects.filter(employee__manager1=employee)    else:        requests = OvertimeRequest.objects.filter(employee=employee)    # Фильтры    reason = request.GET.get('reason')    employee_name = request.GET.get('employee_name')    start_date = request.GET.get('start_date')    end_date = request.GET.get('end_date')    status = request.GET.get('status')    if reason:        requests = requests.filter(reason=reason)    if employee_name and is_manager:        requests = requests.filter(employee__full_name__icontains=employee_name)    if start_date:        requests = requests.filter(start_datetime__date__gte=start_date)    if end_date:        requests = requests.filter(end_datetime__date__lte=end_date)    if status:        requests = requests.filter(status=status)    # Создаем Word документ    doc = Document()    doc.add_heading('Заявки на переработку', 0)    # Добавляем таблицу    table = doc.add_table(rows=1, cols=9)    table.style = 'Table Grid'    # Заголовки    hdr_cells = table.rows[0].cells    hdr_cells[0].text = 'Номер'    hdr_cells[1].text = 'Сотрудник'    hdr_cells[2].text = 'Отдел'    hdr_cells[3].text = 'Начало'    hdr_cells[4].text = 'Окончание'    hdr_cells[5].text = 'Часы'    hdr_cells[6].text = 'Причина'    hdr_cells[7].text = 'Обоснование'    hdr_cells[8].text = 'Статус'    # Данные    for req in requests:        row_cells = table.add_row().cells        row_cells[0].text = str(req.id)        row_cells[1].text = req.employee.full_name or "Не указано"        row_cells[2].text = req.employee.department or "Не указан"        row_cells[3].text = req.start_datetime.strftime('%d.%m.%Y %H:%M')        row_cells[4].text = req.end_datetime.strftime('%d.%m.%Y %H:%M')        row_cells[5].text = f"{req.hours:.2f}"        row_cells[6].text = req.get_reason_display()        row_cells[7].text = req.justification or "Не указано"        row_cells[8].text = req.get_status_display()    # Отправляем файл    response = HttpResponse(content_type='application/vnd.openxmlformats-officedocument.wordprocessingml.document')    response['Content-Disposition'] = f'attachment; filename="requests_{datetime.now().strftime("%Y%m%d_%H%M%S")}.docx"'    doc.save(response)    return response@login_requireddef export_requests(request):    """    Отображает страницу с формой фильтрации и списком заявок для экспорта.    """    employee = Employee.objects.get(email=request.user.email)    is_manager = employee.is_manager    # Начальный queryset    if is_manager:        requests = OvertimeRequest.objects.filter(employee__manager1=employee)    else:        requests = OvertimeRequest.objects.filter(employee=employee)    # Фильтры    reason = request.GET.get('reason')    employee_name = request.GET.get('employee_name')    start_date = request.GET.get('start_date')    end_date = request.GET.get('end_date')    status = request.GET.get('status')    if reason:        requests = requests.filter(reason=reason)    if employee_name and is_manager:        requests = requests.filter(employee__full_name__icontains=employee_name)    if start_date:        requests = requests.filter(start_datetime__date__gte=start_date)    if end_date:        requests = requests.filter(end_datetime__date__lte=end_date)    if status:        requests = requests.filter(status=status)    # Для отображения формы фильтров    reasons = OvertimeRequest.REASON_CHOICES    statuses = OvertimeRequest.STATUS_CHOICES    if is_manager:        employees = Employee.objects.filter(manager1=employee)    else:        employees = Employee.objects.none()    context = {        'requests': requests,        'reasons': reasons,        'statuses': statuses,        'employees': employees,        'is_manager': is_manager,        'filters': {            'reason': reason,            'employee_name': employee_name,            'start_date': start_date,            'end_date': end_date,            'status': status,        }    }    return render(request, 'overtime_app/export_requests.html', context)def portal_login(request):    if request.method == 'POST':        username = request.POST.get('username')        password = request.POST.get('password')        user = authenticate(request, username=username, password=password)        if user is not None:            login(request, user)            return redirect('overtime_app:dashboard')        else:            messages.error(request, 'Неверное имя пользователя или пароль')    return render(request, 'overtime_app/login.html')def register(request):    if request.method == 'POST':        form = EmployeeRegistrationForm(request.POST)        if form.is_valid():            employee = form.save()            messages.success(request, f'Сотрудник {employee.full_name} успешно зарегистрирован!')            return redirect('portal_login')    else:        form = EmployeeRegistrationForm()    return render(request, 'overtime_app/register.html', {'form': form})@login_requireddef dashboard(request):    try:        employee = Employee.objects.get(email=request.user.email)    except Employee.DoesNotExist:        messages.error(request, 'Ваш профиль сотрудника не найден. Пожалуйста, зарегистрируйтесь.')        return redirect('register')    except Employee.MultipleObjectsReturned:        messages.error(request, 'Ошибка: найдено несколько сотрудников с этим email. Обратитесь к администратору.')        return redirect('home')    # Проверим, является ли сотрудник руководителем    is_manager = employee.is_manager    my_requests = OvertimeRequest.objects.filter(employee=employee).order_by('-created_at')    if is_manager:        # Заявки подчинённых        subordinates_requests = OvertimeRequest.objects.filter(            employee__manager1=employee        ).order_by('-created_at')    else:        subordinates_requests = []    context = {        'employee': employee,        'my_requests': my_requests,        'subordinates_requests': subordinates_requests,        'is_manager': is_manager,    }    return render(request, 'overtime_app/dashboard.html', context)@login_requireddef profile_settings(request):    try:        employee = Employee.objects.get(email=request.user.email)    except Employee.DoesNotExist:        messages.error(request, 'Ваш профиль сотрудника не найден.')        return redirect('overtime_app:dashboard')    if request.method == 'POST':        form = EmployeeProfileForm(request.POST, instance=employee)        if form.is_valid():            form.save()            messages.success(request, 'Профиль успешно обновлён!')            return redirect('overtime_app:profile_settings')    else:        form = EmployeeProfileForm(instance=employee)    return render(request, 'overtime_app/profile_settings.html', {'form': form})@login_requireddef create_request(request):    try:        employee = Employee.objects.get(email=request.user.email)    except Employee.DoesNotExist:        messages.error(request, 'Ваш профиль сотрудника не найден.')        return redirect('overtime_app:dashboard')    if request.method == 'POST':        form = OvertimeRequestForm(request.POST)        if form.is_valid():            req = form.save(commit=False)            req.employee = employee            req.status = 'pending' # Устанавливаем статус при создании            req.save()            # Отправить письмо руководителю            manager = req.employee.manager1            if manager and manager.email:                # Создаём токен                token_obj = ApprovalToken.create_token(req, manager)                # Генерируем ссылки                approve_url = request.build_absolute_uri(                    reverse('overtime_app:approve_via_email', args=[req.id]) + f'?token={token_obj.token}&decision=approved'                )                rework_url = request.build_absolute_uri(                    reverse('overtime_app:approve_via_email', args=[req.id]) + f'?token={token_obj.token}&decision=rework'                )                reject_url = request.build_absolute_uri(                    reverse('overtime_app:approve_via_email', args=[req.id]) + f'?token={token_obj.token}&decision=rejected'                )                # HTML-письмо                html_content = f"""                <h2>Заявка на переработку #{req.id}</h2>                <p><strong>Сотрудник:</strong> {req.employee.full_name}</p>                <p><strong>Начало:</strong> {req.start_datetime}</p>                <p><strong>Окончание:</strong> {req.end_datetime}</p>                <p><strong>Причина:</strong> {req.get_reason_display()}</p>                <p><strong>Обоснование:</strong> {req.justification}</p>                <h3>Действия:</h3>                <a href="{approve_url}" style="display:inline-block;padding:10px 20px;background:#4CAF50;color:white;text-decoration:none;border-radius:5px;margin:5px;">Согласовано</a>                <a href="{rework_url}" style="display:inline-block;padding:10px 20px;background:#FF9800;color:white;text-decoration:none;border-radius:5px;margin:5px;">На доработку</a>                <a href="{reject_url}" style="display:inline-block;padding:10px 20px;background:#F44336;color:white;text-decoration:none;border-radius:5px;margin:5px;">Не согласовано</a>                """                msg = EmailMultiAlternatives(                    subject=f'Заявка на переработку #{req.id} от {req.employee.full_name}',                    body=f'Заявка #{req.id} ждет вашего согласования. Перейдите по ссылке: {approve_url}',                    from_email=None,                    to=[manager.email],                )                msg.attach_alternative(html_content, "text/html")                msg.send()            messages.success(request, 'Заявка создана и отправлена на согласование.')            return redirect('overtime_app:dashboard')    else:        form = OvertimeRequestForm()    return render(request, 'overtime_app/create_request.html', {'form': form})@login_requireddef my_requests(request):    try:        employee = Employee.objects.get(email=request.user.email)    except Employee.DoesNotExist:        messages.error(request, 'Ваш профиль сотрудника не найден.')        return redirect('overtime_app:dashboard')    requests = OvertimeRequest.objects.filter(employee=employee).order_by('-created_at')    return render(request, 'overtime_app/my_requests.html', {'requests': requests})def home(request):    return render(request, 'overtime_app/home.html')@login_requireddef view_requests(request):    if not request.user.is_authenticated:        return redirect('portal_login')    try:        employee = Employee.objects.get(email=request.user.email)    except Employee.DoesNotExist:        messages.error(request, 'Ваш профиль сотрудника не найден.')        return redirect('overtime_app:dashboard')    # Только руководитель может видеть заявки подчинённых    # Проверяем, есть ли у сотрудника подчиненные    is_manager = employee.is_manager    if not is_manager:        messages.error(request, 'У вас нет прав для просмотра заявок подчинённых')        return redirect('overtime_app:dashboard')    requests = OvertimeRequest.objects.filter(        employee__manager1=employee    ).order_by('-created_at')    return render(request, 'overtime_app/view_requests.html', {'requests': requests})