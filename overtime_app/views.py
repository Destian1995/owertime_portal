from collections import defaultdictfrom datetime import timedeltafrom django.shortcuts import render, get_object_or_404, redirectfrom django.core.mail import send_mail, EmailMultiAlternativesfrom django.contrib.auth.decorators import login_requiredfrom django.contrib.auth import login, authenticatefrom docx import Documentfrom django.urls import reversefrom datetime import datetimefrom django.utils import timezonefrom .models import OvertimeRequest, Employee, ApprovalLog, Position, ApprovalTokenfrom .forms import OvertimeRequestForm, EmployeeProfileFormfrom django.db.models import Case, When, Value, IntegerFieldfrom django.contrib.auth.views import LogoutView as DjangoLogoutViewfrom django.http import JsonResponsefrom django.contrib import messagesfrom django.shortcuts import render, redirectfrom django.contrib.auth.models import Userfrom .forms import ResetPasswordFormimport mimetypesimport osfrom django.conf import settingsfrom django.http import HttpResponse, FileResponse, Http404from django.contrib.auth.decorators import login_requireddef reset_password(request):    if request.method == 'POST':        form = ResetPasswordForm(request.POST)        if form.is_valid():            username = form.cleaned_data['username']            new_password = form.cleaned_data['new_password1']            user = User.objects.get(username=username)            user.set_password(new_password)            user.save()            messages.success(request, 'Пароль успешно изменён. Теперь вы можете войти.')            return redirect('portal_login')    else:        form = ResetPasswordForm()    return render(request, 'overtime_app/reset_password.html', {'form': form})class LogoutView(DjangoLogoutView):    http_method_names = ['get', 'post']def request_access(request):    if request.method == 'POST':        # Отправить письмо администратору        try:            send_mail(                subject='Запрос доступа к порталу',                message=f'Пользователь с IP-адреса {request.META.get("REMOTE_ADDR")} запросил доступ к порталу.',                from_email=None,  # Использует DEFAULT_FROM_EMAIL                recipient_list=['ServiseDesk@aton.ru'],  # email техподдержки            )            return JsonResponse({'success': True})        except Exception as e:            print(f'Ошибка отправки письма: {e}')            return JsonResponse({'success': False})    return JsonResponse({'success': False})# Исправленная функция process_approvaldef process_approval(req, approver, decision, comment):    """    Обрабатывает решение по заявке: создает запись в логе, обновляет статус, отправляет уведомление.    """    # Создаем запись согласования    ApprovalLog.objects.create(        request=req,        approver=approver,        decision=decision,        comment=comment    )    # Обновляем статус    if decision == 'approved':        req.status = 'approved'    elif decision == 'rejected':        req.status = 'rejected'    req.save()    # Отправляем уведомление сотруднику, если email действителен    if req.employee.email:        try:            # Подробное сообщение для сотрудника            subject = f'Заявка #{req.id} на переработку {req.get_status_display()}'            text_content = f"""            Ваша заявка на переработку (#{req.id}) была {req.get_status_display()}.            Детали:            - Сотрудник: {req.employee.full_name}            - Начало: {req.start_datetime.strftime('%d.%m.%Y %H:%M')}            - Окончание: {req.end_datetime.strftime('%d.%m.%Y %H:%M')}            - Количество часов: {req.hours:.2f}            - Причина: {req.get_reason_display()}            - Обоснование: {req.justification or "Не указано"}            - Решение принято: {approver.full_name}            - Комментарий: {comment if comment else "Не предоставлен"}            """            html_content = f"""            <html>            <body>                <h2>Заявка на переработку #{req.id}</h2>                <p><strong>Статус:</strong> {req.get_status_display()}</p>                <h3>Детали:</h3>                <ul>                    <li><strong>Сотрудник:</strong> {req.employee.full_name}</li>                    <li><strong>Начало:</strong> {req.start_datetime.strftime('%d.%m.%Y %H:%M')}</li>                    <li><strong>Окончание:</strong> {req.end_datetime.strftime('%d.%m.%Y %H:%M')}</li>                    <li><strong>Количество часов:</strong> {req.hours:.2f}</li>                    <li><strong>Причина:</strong> {req.get_reason_display()}</li>                    <li><strong>Обоснование:</strong> {req.justification or "Не указано"}</li>                    <li><strong>Решение принято:</strong> {approver.full_name}</li>                    <li><strong>Комментарий:</strong> {comment if comment else "Не предоставлен"}</li>                </ul>            </body>            </html>            """            msg = EmailMultiAlternatives(                subject=subject,                body=text_content,  # Текстовая версия на случай, если HTML недоступен                from_email=None,  # Использует DEFAULT_FROM_EMAIL                to=[req.employee.email],            )            msg.attach_alternative(html_content, "text/html")            msg.send()        except Exception as e:            # Логируем ошибку, но не останавливаем выполнение            print(f"Ошибка отправки email на {req.employee.email}: {e}")    # Помечаем токен как использованный    try:        token_obj = ApprovalToken.objects.get(request=req, approver=approver, used=False)        token_obj.used = True        token_obj.save()    except ApprovalToken.DoesNotExist:        pass@login_requireddef change_status(request, req_id):    """    Позволяет руководителю изменить статус заявки на "Согласовано" или "Не согласовано".    """    if request.method != 'POST':        return redirect('overtime_app:view_requests')    req = get_object_or_404(OvertimeRequest, id=req_id)    # Получаем текущего пользователя (руководителя)    try:        approver = Employee.objects.get(email=request.user.email)    except Employee.DoesNotExist:        messages.error(request, 'Ваш профиль сотрудника не найден.')        return redirect('overtime_app:dashboard')    # Проверяем, является ли текущий пользователь правильным согласующим    if req.employee.manager1 != approver:        messages.error(request, 'У вас нет прав для согласования этой заявки.')        return redirect('overtime_app:view_requests')    decision = request.POST.get('decision')    if decision not in ['approved', 'rejected']:        messages.error(request, 'Неверное действие.')        return redirect('overtime_app:view_requests')    comment = request.POST.get('comment', '')    # Используем общую функцию обработки    process_approval(req, approver, decision, comment)    messages.success(request, f'Заявка #{req.id} была {"согласована" if decision == "approved" else "отклонена"}.')    return redirect('overtime_app:view_requests')# Исправленная функция approve_via_email (проверка токена и завершение логики)@login_requireddef approve_via_email(request, req_id):    """    Обрабатывает согласование/отклонение заявки через email-ссылку.    """    req = get_object_or_404(OvertimeRequest, id=req_id)    token = request.GET.get('token')    decision = request.GET.get('decision')    if decision not in ['approved', 'rejected']:  # Убрали 'rework'        messages.error(request, 'Неверное действие.')        return redirect('overtime_app:dashboard')    # Проверка токена    try:        token_obj = ApprovalToken.objects.get(token=token, request=req)        # Проверка валидности токена        if token_obj.used or token_obj.expires_at < timezone.now():            messages.error(request, 'Ссылка недействительна или истекла.')            return redirect('overtime_app:dashboard')    except ApprovalToken.DoesNotExist:        messages.error(request, 'Неверная ссылка.')        return redirect('overtime_app:dashboard')    # Получаем текущего пользователя (руководителя)    try:        approver = Employee.objects.get(email=request.user.email)    except Employee.DoesNotExist:        messages.error(request, 'Ваш профиль сотрудника не найден.')        return redirect('overtime_app:dashboard')    # Проверяем, является ли текущий пользователь правильным согласующим    if token_obj.approver != approver:        messages.error(request, 'Недостаточно прав для согласования.')        return redirect('overtime_app:dashboard')    # Обработка решения    comment = request.GET.get('comment', '')    process_approval(req, approver, decision, comment)    messages.success(request, f'Заявка #{req.id} была {"согласована" if decision == "approved" else "отклонена"}.')  # Убрали "на доработку"    return redirect('overtime_app:dashboard')# Исправленная функция approve_request - теперь обрабатывает POST-запросы из веб-интерфейса@login_requireddef approve_request(request, req_id):    """    Обрабатывает согласование/отклонение заявки через веб-интерфейс.    """    if request.method != 'POST':        return redirect('overtime_app:dashboard')    req = get_object_or_404(OvertimeRequest, id=req_id)    # Получаем текущего пользователя (руководителя)    try:        approver = Employee.objects.get(email=request.user.email)    except Employee.DoesNotExist:        messages.error(request, 'Ваш профиль сотрудника не найден.')        return redirect('overtime_app:dashboard')    # Проверяем, является ли текущий пользователь правильным согласующим    # (например, manager1). Можно расширить логику для manager2.    if req.employee.manager1 != approver:        messages.error(request, 'У вас нет прав для согласования этой заявки.')        return redirect('overtime_app:dashboard')    decision = request.POST.get('decision')    if decision not in ['approved', 'rejected']:  # Убрали 'rework'        messages.error(request, 'Неверное действие.')        return redirect('overtime_app:dashboard')    comment = request.POST.get('comment', '')    # Используем общую функцию обработки    process_approval(req, approver, decision, comment)    messages.success(request, f'Заявка #{req.id} была {"согласована" if decision == "approved" else "отклонена"}.')  # Убрали "на доработку"    return redirect('overtime_app:dashboard')@login_requireddef export_requests(request):    """    Отображает страницу с формой фильтрации и списком заявок для экспорта.    """    employee = Employee.objects.get(email=request.user.email)    is_manager = employee.is_manager    # Начальный queryset для отображения    if is_manager:        # Показываем все заявки подчинённых        requests = OvertimeRequest.objects.filter(employee__manager1=employee)    else:        # Показываем только заявки текущего сотрудника        requests = OvertimeRequest.objects.filter(employee=employee)    # Применяем фильтры из формы для отображения    reason = request.GET.get('reason')    employee_name = request.GET.get('employee_name')    start_date_str = request.GET.get('start_date')    end_date_str = request.GET.get('end_date')    status = request.GET.get('status')    if reason:        requests = requests.filter(reason=reason)    if employee_name and is_manager:        # Фильтруем по имени сотрудника (подчинённого)        requests = requests.filter(employee__full_name__icontains=employee_name)    if start_date_str:        try:            start_date = datetime.strptime(start_date_str, '%Y-%m-%d').date()            # Фильтр по дате: начало заявки <= конец_фильтра И конец заявки >= начало_фильтра (пересечение)            requests = requests.filter(end_datetime__date__gte=start_date)        except ValueError:            messages.error(request, 'Неверный формат даты начала.')            # Возвращаем пустой список или обработайте ошибку по-другому            requests = OvertimeRequest.objects.none()    if end_date_str:        try:            end_date = datetime.strptime(end_date_str, '%Y-%m-%d').date()            # Фильтр по дате: начало заявки <= конец_фильтра И конец заявки >= начало_фильтра (пересечение)            requests = requests.filter(start_datetime__date__lte=end_date)        except ValueError:            messages.error(request, 'Неверный формат даты окончания.')            # Возвращаем пустой список или обработайте ошибку по-другому            requests = OvertimeRequest.objects.none()    if status:        requests = requests.filter(status=status)    # Для отображения формы фильтров    reasons = OvertimeRequest.REASON_CHOICES    statuses = OvertimeRequest.STATUS_CHOICES    if is_manager:        # Для формы фильтрации показываем всех подчинённых менеджера        employees = Employee.objects.filter(manager1=employee)    else:        employees = Employee.objects.none()    context = {        'requests': requests, # Передаём отфильтрованные заявки для отображения        'reasons': reasons,        'statuses': statuses,        'employees': employees,        'is_manager': is_manager,        'filters': {            'reason': reason,            'employee_name': employee_name,            'start_date': start_date_str,            'end_date': end_date_str,            'status': status,        }    }    return render(request, 'overtime_app/export_requests.html', context)@login_requireddef export_requests_word(request):    """    Экспортирует заявки подчинённых в документ Word по шаблону служебной записки.    Использует фильтры: start_date, end_date, employee_name, status, reason.    Группирует строки по сотруднику. Вставляет уникальные причины (reason).    Использует ручную должность (job_title_manual) и подразделение (department).    Разбивает заявки по дням, равномерно распределяя часы.    """    employee = Employee.objects.get(email=request.user.email)    # Только менеджеры могут экспортировать заявки подчинённых    if not employee.is_manager:        messages.error(request, 'У вас нет прав для экспорта заявок подчинённых.')        return redirect('overtime_app:dashboard')    # --- Применение фильтров ---    # Получаем фильтры из URL-параметров    employee_name_filter = request.GET.get('employee_name')    start_date_str = request.GET.get('start_date')    end_date_str = request.GET.get('end_date')    status_filter = request.GET.get('status')    reason_filter = request.GET.get('reason')    # Начальный queryset - заявки подчинённых    requests = OvertimeRequest.objects.filter(employee__manager1=employee).select_related('employee')    # Применяем фильтр по имени сотрудника (если указан)    if employee_name_filter:        requests = requests.filter(employee__full_name__icontains=employee_name_filter)    # Применяем фильтр по статусу (если указан)    if status_filter:        requests = requests.filter(status=status_filter)    # Применяем фильтр по причине (если указана)    if reason_filter:        requests = requests.filter(reason=reason_filter)    # Применяем фильтр по дате (если указаны)    start_date = None    end_date = None    if start_date_str:        try:            start_date = datetime.strptime(start_date_str, '%Y-%m-%d').date()        except ValueError:            messages.error(request, 'Неверный формат даты начала.')            return redirect('overtime_app:export_requests')    if end_date_str:        try:            end_date = datetime.strptime(end_date_str, '%Y-%m-%d').date()        except ValueError:            messages.error(request, 'Неверный формат даты окончания.')            return redirect('overtime_app:export_requests')    # Проверяем, что даты указаны    if not start_date or not end_date:        messages.error(request, 'Для выгрузки по шаблону необходимо указать начальную и конечную даты.')        return redirect('overtime_app:export_requests')    # Проверяем, что даты находятся в одном календарном месяце и году    if start_date.month != end_date.month or start_date.year != end_date.year:        messages.error(request, 'Даты должны быть в пределах одного календарного месяца и года.')        return redirect('overtime_app:export_requests')    # Применяем фильтр по датам: пересечение интервалов    # Заявка подходит, если: (start_req <= end_filter AND end_req >= start_filter)    requests = requests.filter(        start_datetime__date__lte=end_date, # Заявка начинается до или в конечную дату фильтра        end_datetime__date__gte=start_date  # Заявка заканчивается после или в начальную дату фильтра    )    if not requests.exists():        messages.warning(request, 'Нет заявок подчинённых по указанным фильтрам для выгрузки.')        return redirect('overtime_app:export_requests') # Вернуться на страницу фильтров    # --- Вычисления для документа ---    # Месяц и год из фильтра    # Словарь для русских названий месяцев    month_names_rus = {        1: 'январе', 2: 'феврале', 3: 'марте', 4: 'апреле', 5: 'мае', 6: 'июне',        7: 'июле', 8: 'августе', 9: 'сентябре', 10: 'октябре', 11: 'ноябре', 12: 'декабре'    }    month_name_rus = month_names_rus.get(start_date.month, 'месяце')    year = start_date.year    # Уникальные ПРИЧИНЫ (reason) из заявок (используем отображаемое имя)    unique_reasons = set(req.get_reason_display() for req in requests)    reasons_text = ', '.join(unique_reasons) if unique_reasons else 'Не указано'    # --- Генерация документа Word ---    doc = Document()    # Добавляем параграф "Генеральному директору"    p_director = doc.add_paragraph()    p_director.add_run('Генеральному директору\n').bold = True    p_director.add_run('ООО « АТОН»\n').bold = True    p_director.add_run('Звездочкину А.М.\n').bold = True    p_director.alignment = 2 # 2 = RIGHT    # Добавляем отступ    doc.add_paragraph()    # Добавляем основной текст    p_main = doc.add_paragraph()    p_main.add_run('СЛУЖЕБНАЯ ЗАПИСКА\n').bold = True    p_main.alignment = 1 # 1 = CENTER    # Вставляем месяц и год в основной текст    main_text_run = p_main.add_run(f'В связи с производственной необходимостью прошу привлечь к работе в выходные дни в ')    main_text_run = p_main.add_run(f'{month_name_rus} ').bold = True # Жирный месяц    main_text_run = p_main.add_run(f'{year} г. следующих работников:\n') # Год    # Добавляем таблицу    # № | ФИО | Должность, подразделение | Дата работы | Количество рабочих часов | Ознакомлен, с выходом согласен    table = doc.add_table(rows=1, cols=6)    table.style = 'Table Grid'    # Заголовки таблицы    hdr_cells = table.rows[0].cells    hdr_cells[0].text = '№'    hdr_cells[1].text = 'ФИО'    hdr_cells[2].text = 'Должность, подразделение'    hdr_cells[3].text = 'Дата работы'    hdr_cells[4].text = 'Количество рабочих часов'    hdr_cells[5].text = 'Ознакомлен, с выходом согласен'    # Группировка заявок по сотруднику    grouped_requests = defaultdict(list)    for req in requests:        grouped_requests[req.employee].append(req)    row_counter = 1    for emp, emp_requests in grouped_requests.items():        # Сортируем заявки сотрудника по дате начала        sorted_emp_requests = sorted(emp_requests, key=lambda x: x.start_datetime)        # Создаем строку для сотрудника        row_cells = table.add_row().cells        row_cells[0].text = str(row_counter)        row_cells[1].text = emp.full_name or "Не указано"        # Используем ручную должность (job_title_manual) и подразделение (department)        job_title_text = emp.job_title_manual or "Должность не указана" # Резервное значение        dept_text = emp.department if emp.department else "Подразделение не указано"        row_cells[2].text = f"{job_title_text}, {dept_text}"        # --- НОВАЯ ЛОГИКА: Разбиение заявок по дням ---        all_dates = []        all_hours = []        for req in sorted_emp_requests:            # Определяем дни, в которые происходила работа            current_day = req.start_datetime.date()            end_day = req.end_datetime.date()            # Вычисляем количество дней (включая обе даты)            num_days = (end_day - current_day).days + 1            # Вычисляем часы в день            hours_per_day = req.hours / num_days if num_days > 0 else 0            # Проходим по каждому дню            for i in range(num_days):                day = current_day + timedelta(days=i)                all_dates.append(day.strftime('%d.%m.%Y'))                # Округляем часы до 2 знаков после запятой для читаемости                all_hours.append(f"{hours_per_day:.2f}")        # Объединяем даты и часы в строки для ячеек        dates_str = "\n".join(all_dates)        hours_str = "\n".join(all_hours)        row_cells[3].text = dates_str        row_cells[4].text = hours_str        # Ячейка "Ознакомлен" - оставляем пустой для заполнения вручную        row_cells[5].text = ""        row_counter += 1 # Увеличиваем счётчик строки    # Добавляем пустой параграф (отступ)    doc.add_paragraph()    # Добавляем текст "Работа, выполненная в этот день:" и причины (reason)    p_justification = doc.add_paragraph()    p_justification.add_run('Работа, выполненная в этот день: ').bold = True    p_justification.add_run(reasons_text)    # Добавляем пустой параграф (отступ)    doc.add_paragraph()    # Добавляем текст про компенсацию    p_compensation = doc.add_paragraph()    p_compensation.add_run('Прошу произвести компенсацию в ')    p_compensation.add_run('денежной форме ').bold = True # Жирная "денежной форме"    p_compensation.add_run('/ в виде предоставления другого дня отдыха.')    # Добавляем пустой параграф (отступ)    doc.add_paragraph()    # Добавляем подпись и ФИО    p_signature = doc.add_paragraph()    p_signature.add_run('_________________/').bold = True    p_signature.add_run(f'{employee.full_name} /').bold = True    p_signature.alignment = 2 # RIGHT    # --- Отправка файла ---    response = HttpResponse(content_type='application/vnd.openxmlformats-officedocument.wordprocessingml.document')    response['Content-Disposition'] = f'attachment; filename="Sluzhebka_podchinyonie_{month_name_rus}_{year}_{datetime.now().strftime("%Y%m%d_%H%M%S")}.docx"'    doc.save(response)    return responsedef portal_login(request):    if request.method == 'POST':        username = request.POST.get('username')        password = request.POST.get('password')        user = authenticate(request, username=username, password=password)        if user is not None:            login(request, user)            return redirect('overtime_app:dashboard')        else:            messages.error(request, 'Неверное имя пользователя или пароль')    return render(request, 'overtime_app/login.html')@login_requireddef dashboard(request):    try:        employee = Employee.objects.get(email=request.user.email)    except Employee.DoesNotExist:        # Если профиль сотрудника не найден, отправляем на главную страницу        messages.error(request, 'Ваш профиль сотрудника не найден. Обратитесь к администратору.')        return redirect('home') # 'home' существует в основном urls.py    except Employee.MultipleObjectsReturned:        messages.error(request, 'Ошибка: найдено несколько сотрудников с этим email. Обратитесь к администратору.')        return redirect('home')    # Проверим, является ли сотрудник руководителем    is_manager = employee.is_manager    my_requests = OvertimeRequest.objects.filter(employee=employee).order_by('-created_at')    if is_manager:        # Заявки подчинённых, отсортированные: сначала "На согласовании", потом остальные        subordinates_requests = OvertimeRequest.objects.filter(            employee__manager1=employee        ).annotate(            custom_order=Case(                When(status='pending', then=Value(0)),                default=Value(1),                output_field=IntegerField()            )        ).order_by('custom_order', '-created_at')    else:        subordinates_requests = []    context = {        'employee': employee,        'my_requests': my_requests,        'subordinates_requests': subordinates_requests,        'is_manager': is_manager,    }    return render(request, 'overtime_app/dashboard.html', context)@login_requireddef create_request(request):    user = request.user    current_user_employee = Employee.objects.filter(email=user.email).first()    if request.method == 'POST':        form = OvertimeRequestForm(            request.POST,            request.FILES,            current_user_employee=current_user_employee        )        if form.is_valid():            overtime_request = form.save(commit=False)            overtime_request.employee = current_user_employee            # Если руководитель создал заявку за подчинённого            subordinate = form.cleaned_data.get('subordinate_employee')            if subordinate:                overtime_request.employee = subordinate            overtime_request.save()            return redirect('overtime_app:dashboard')    else:        form = OvertimeRequestForm(current_user_employee=current_user_employee)    return render(request, 'overtime_app/create_request.html', {        'form': form,        'is_manager': current_user_employee.is_manager if current_user_employee else False    })@login_requireddef my_requests(request):    try:        employee = Employee.objects.get(email=request.user.email)    except Employee.DoesNotExist:        messages.error(request, 'Ваш профиль сотрудника не найден.')        return redirect('overtime_app:dashboard')    requests = OvertimeRequest.objects.filter(employee=employee).order_by('-created_at')    return render(request, 'overtime_app/my_requests.html', {'requests': requests})def home(request):    return render(request, 'overtime_app/home.html')@login_requireddef view_requests(request):    if not request.user.is_authenticated:        return redirect('portal_login')    try:        employee = Employee.objects.get(email=request.user.email)    except Employee.DoesNotExist:        messages.error(request, 'Ваш профиль сотрудника не найден.')        return redirect('overtime_app:dashboard')    # Только руководитель может видеть заявки подчинённых    # Проверяем, есть ли у сотрудника подчиненные    is_manager = employee.is_manager    if not is_manager:        messages.error(request, 'У вас нет прав для просмотра заявок подчинённых')        return redirect('overtime_app:dashboard')    requests = OvertimeRequest.objects.filter(        employee__manager1=employee    ).order_by('-created_at')    return render(request, 'overtime_app/view_requests.html', {'requests': requests})@login_requireddef serve_text_file(request, filename):    """    Отдаёт файл из MEDIA_ROOT/overtime_attachments/ с корректной кодировкой UTF-8.    Если файл не текстовый — отдаёт его как бинарный.    """    file_path = os.path.join(settings.MEDIA_ROOT, 'overtime_attachments', filename)    if not os.path.exists(file_path):        raise Http404("Файл не найден")    content_type, _ = mimetypes.guess_type(file_path)    # Текстовые файлы читаем как UTF-8    if content_type and content_type.startswith("text/"):        try:            with open(file_path, "r", encoding="utf-8") as f:                content = f.read()        except UnicodeDecodeError:            # если файл не в utf-8, можно fallback            with open(file_path, "r", encoding="cp1251", errors="replace") as f:                content = f.read()        return HttpResponse(content, content_type=f"{content_type}; charset=utf-8")    # Остальные файлы — как бинарные (например, .xlsx, .pdf)    return FileResponse(open(file_path, "rb"), content_type=content_type or "application/octet-stream")