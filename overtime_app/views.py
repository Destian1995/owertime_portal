import secretsfrom collections import defaultdictfrom datetime import timedeltafrom django.shortcuts import render, get_object_or_404, redirectfrom django.core.mail import send_mail, EmailMultiAlternativesfrom django.contrib.sites.models import Sitefrom django.contrib.auth import login, authenticatefrom django.views.decorators.http import require_http_methodsfrom docx import Documentfrom django.urls import reversefrom datetime import datetimefrom django.utils import timezonefrom .models import OvertimeRequest, Employee, ApprovalLog, Position, ApprovalTokenfrom .forms import OvertimeRequestForm, EmployeeProfileFormfrom django.db.models import Case, When, Value, IntegerFieldfrom django.contrib.auth.views import LogoutView as DjangoLogoutViewfrom django.http import JsonResponsefrom django.contrib import messagesfrom django.shortcuts import render, redirectfrom django.contrib.auth.models import Userfrom .forms import ResetPasswordFormimport mimetypesimport osfrom django.conf import settingsfrom django.http import HttpResponse, FileResponse, Http404from django.contrib.auth.decorators import login_requireddef reset_password(request):    if request.method == 'POST':        form = ResetPasswordForm(request.POST)        if form.is_valid():            username = form.cleaned_data['username']            new_password = form.cleaned_data['new_password1']            user = User.objects.get(username=username)            user.set_password(new_password)            user.save()            messages.success(request, 'Пароль успешно изменён. Теперь вы можете войти.')            return redirect('portal_login')    else:        form = ResetPasswordForm()    return render(request, 'overtime_app/reset_password.html', {'form': form})class LogoutView(DjangoLogoutView):    http_method_names = ['get', 'post']def request_access(request):    if request.method == 'POST':        # Отправить письмо администратору        try:            send_mail(                subject='Запрос доступа к порталу',                message=f'Пользователь с IP-адреса {request.META.get("REMOTE_ADDR")} запросил доступ к порталу.',                from_email=None,  # Использует DEFAULT_FROM_EMAIL                recipient_list=['ServiseDesk@aton.ru'],  # email техподдержки            )            return JsonResponse({'success': True})        except Exception as e:            print(f'Ошибка отправки письма: {e}')            return JsonResponse({'success': False})    return JsonResponse({'success': False})# Исправленная функция process_approvaldef process_approval(req, approver, decision, comment):    """    Обрабатывает решение по заявке: создает запись в логе, обновляет статус, отправляет уведомление.    """    # Создаем запись согласования    ApprovalLog.objects.create(        request=req,        approver=approver,        decision=decision,        comment=comment    )    # Обновляем статус    if decision == 'approved':        req.status = 'approved'    elif decision == 'rejected':        req.status = 'rejected'    req.save()    # Отправляем уведомление сотруднику, если email действителен    if req.employee.email:        try:            # Подробное сообщение для сотрудника            subject = f'Заявка #{req.id} на переработку {req.get_status_display()}'            text_content = f"""            Ваша заявка на переработку (#{req.id}) была {req.get_status_display()}.            Детали:            - Сотрудник: {req.employee.full_name}            - Начало: {req.start_datetime.strftime('%d.%m.%Y %H:%M')}            - Окончание: {req.end_datetime.strftime('%d.%m.%Y %H:%M')}            - Количество часов: {req.hours:.2f}            - Причина: {req.get_reason_display()}            - Обоснование: {req.justification or "Не указано"}            - Решение принято: {approver.full_name}            - Комментарий: {comment if comment else "Не предоставлен"}            """            html_content = f"""            <html>            <body>                <h2>Заявка на переработку #{req.id}</h2>                <p><strong>Статус:</strong> {req.get_status_display()}</p>                <h3>Детали:</h3>                <ul>                    <li><strong>Сотрудник:</strong> {req.employee.full_name}</li>                    <li><strong>Начало:</strong> {req.start_datetime.strftime('%d.%m.%Y %H:%M')}</li>                    <li><strong>Окончание:</strong> {req.end_datetime.strftime('%d.%m.%Y %H:%M')}</li>                    <li><strong>Количество часов:</strong> {req.hours:.2f}</li>                    <li><strong>Причина:</strong> {req.get_reason_display()}</li>                    <li><strong>Обоснование:</strong> {req.justification or "Не указано"}</li>                    <li><strong>Решение принято:</strong> {approver.full_name}</li>                    <li><strong>Комментарий:</strong> {comment if comment else "Не предоставлен"}</li>                </ul>            </body>            </html>            """            msg = EmailMultiAlternatives(                subject=subject,                body=text_content,  # Текстовая версия на случай, если HTML недоступен                from_email=None,  # Использует DEFAULT_FROM_EMAIL                to=[req.employee.email],            )            msg.attach_alternative(html_content, "text/html")            msg.send()        except Exception as e:            # Логируем ошибку, но не останавливаем выполнение            print(f"Ошибка отправки email на {req.employee.email}: {e}")    # Помечаем токен как использованный    try:        token_obj = ApprovalToken.objects.get(request=req, approver=approver, used=False)        token_obj.used = True        token_obj.save()    except ApprovalToken.DoesNotExist:        pass@login_requireddef change_status(request, req_id):    """    Позволяет руководителю изменить статус заявки на "Согласовано" или "Не согласовано".    """    if request.method != 'POST':        return redirect('overtime_app:view_requests')    req = get_object_or_404(OvertimeRequest, id=req_id)    # Получаем текущего пользователя (руководителя)    try:        approver = Employee.objects.get(email=request.user.email)    except Employee.DoesNotExist:        messages.error(request, 'Ваш профиль сотрудника не найден.')        return redirect('overtime_app:dashboard')    # Проверяем, является ли текущий пользователь правильным согласующим    if req.employee.manager1 != approver:        messages.error(request, 'У вас нет прав для согласования этой заявки.')        return redirect('overtime_app:view_requests')    decision = request.POST.get('decision')    if decision not in ['approved', 'rejected']:        messages.error(request, 'Неверное действие.')        return redirect('overtime_app:view_requests')    comment = request.POST.get('comment', '')    # Используем общую функцию обработки    process_approval(req, approver, decision, comment)    messages.success(request, f'Заявка #{req.id} была {"согласована" if decision == "approved" else "отклонена"}.')    return redirect('overtime_app:view_requests')# Исправленная функция approve_via_email (проверка токена и завершение логики)@login_requireddef approve_via_email(request, req_id):    """    Обрабатывает согласование/отклонение заявки через email-ссылку.    """    req = get_object_or_404(OvertimeRequest, id=req_id)    token = request.GET.get('token')    decision = request.GET.get('decision')    if decision not in ['approved', 'rejected']:  # Убрали 'rework'        messages.error(request, 'Неверное действие.')        return redirect('overtime_app:dashboard')    # Проверка токена    try:        token_obj = ApprovalToken.objects.get(token=token, request=req)        # Проверка валидности токена        if token_obj.used or token_obj.expires_at < timezone.now():            messages.error(request, 'Ссылка недействительна или истекла.')            return redirect('overtime_app:dashboard')    except ApprovalToken.DoesNotExist:        messages.error(request, 'Неверная ссылка.')        return redirect('overtime_app:dashboard')    # Получаем текущего пользователя (руководителя)    try:        approver = Employee.objects.get(email=request.user.email)    except Employee.DoesNotExist:        messages.error(request, 'Ваш профиль сотрудника не найден.')        return redirect('overtime_app:dashboard')    # Проверяем, является ли текущий пользователь правильным согласующим    if token_obj.approver != approver:        messages.error(request, 'Недостаточно прав для согласования.')        return redirect('overtime_app:dashboard')    # Обработка решения    comment = request.GET.get('comment', '')    process_approval(req, approver, decision, comment)    messages.success(request, f'Заявка #{req.id} была {"согласована" if decision == "approved" else "отклонена"}.')  # Убрали "на доработку"    return redirect('overtime_app:dashboard')# Исправленная функция approve_request - теперь обрабатывает POST-запросы из веб-интерфейса@login_requireddef approve_request(request, req_id):    """    Обрабатывает согласование/отклонение заявки через веб-интерфейс.    """    if request.method != 'POST':        return redirect('overtime_app:dashboard')    req = get_object_or_404(OvertimeRequest, id=req_id)    # Получаем текущего пользователя (руководителя)    try:        approver = Employee.objects.get(email=request.user.email)    except Employee.DoesNotExist:        messages.error(request, 'Ваш профиль сотрудника не найден.')        return redirect('overtime_app:dashboard')    # Проверяем, является ли текущий пользователь правильным согласующим    # (например, manager1). Можно расширить логику для manager2.    if req.employee.manager1 != approver:        messages.error(request, 'У вас нет прав для согласования этой заявки.')        return redirect('overtime_app:dashboard')    decision = request.POST.get('decision')    if decision not in ['approved', 'rejected']:  # Убрали 'rework'        messages.error(request, 'Неверное действие.')        return redirect('overtime_app:dashboard')    comment = request.POST.get('comment', '')    # Используем общую функцию обработки    process_approval(req, approver, decision, comment)    messages.success(request, f'Заявка #{req.id} была {"согласована" if decision == "approved" else "отклонена"}.')  # Убрали "на доработку"    return redirect('overtime_app:dashboard')@login_requireddef export_requests(request):    """    Отображает страницу с формой фильтрации и списком заявок для экспорта.    """    employee = Employee.objects.get(email=request.user.email)    is_manager = employee.is_manager    # --- Определение фильтра ---    filter_type = request.GET.get('filter', 'my') # По умолчанию 'my'    # Определяем, отображаем ли мы заявки подчинённых или свои    show_subordinates = (filter_type == 'subordinates' and is_manager)    # Определяем, отображаем ли мы свои заявки (для обычного сотрудника или как 'my' для менеджера)    show_my = (filter_type == 'my' or (not is_manager and filter_type != 'subordinates'))    # Начальный queryset для отображения    if show_subordinates:        # Показываем все заявки подчинённых        requests = OvertimeRequest.objects.filter(employee__manager1=employee)    elif show_my:        # Показываем только заявки текущего сотрудника        requests = OvertimeRequest.objects.filter(employee=employee)    else:        # Если фильтр не 'my' и не 'subordinates', или пользователь не менеджер, но пытается увидеть subordinates        # Возвращаем пустой queryset или редиректим        requests = OvertimeRequest.objects.none()        # messages.error(request, 'Недостаточно прав или неверный фильтр.')        # return redirect('overtime_app:dashboard') # Опционально, редирект    # Применяем фильтры из формы для отображения    reason = request.GET.get('reason')    employee_name = request.GET.get('employee_name')    start_date_str = request.GET.get('start_date')    end_date_str = request.GET.get('end_date')    status = request.GET.get('status')    if reason:        requests = requests.filter(reason=reason)    if employee_name and is_manager:        # Фильтруем по имени сотрудника (подчинённого)        requests = requests.filter(employee__full_name__icontains=employee_name)    if start_date_str:        try:            start_date = datetime.strptime(start_date_str, '%Y-%m-%d').date()            # Фильтр по дате: начало заявки <= конец_фильтра И конец заявки >= начало_фильтра (пересечение)            requests = requests.filter(end_datetime__date__gte=start_date)        except ValueError:            messages.error(request, 'Неверный формат даты начала.')            # Возвращаем пустой список или обработайте ошибку по-другому            requests = OvertimeRequest.objects.none()    if end_date_str:        try:            end_date = datetime.strptime(end_date_str, '%Y-%m-%d').date()            # Фильтр по дате: начало заявки <= конец_фильтра И конец заявки >= начало_фильтра (пересечение)            requests = requests.filter(start_datetime__date__lte=end_date)        except ValueError:            messages.error(request, 'Неверный формат даты окончания.')            # Возвращаем пустой список или обработайте ошибку по-другому            requests = OvertimeRequest.objects.none()    if status:        requests = requests.filter(status=status)    # Для отображения формы фильтров    reasons = OvertimeRequest.REASON_CHOICES    statuses = OvertimeRequest.STATUS_CHOICES    if is_manager:        # Для формы фильтрации показываем всех подчинённых менеджера (только если показываем подчинённых)        if show_subordinates:            employees = Employee.objects.filter(manager1=employee)        else:            employees = Employee.objects.none()    else:        employees = Employee.objects.none()    context = {        'requests': requests, # Передаём отфильтрованные заявки для отображения        'reasons': reasons,        'statuses': statuses,        'employees': employees,        'is_manager': is_manager,        'filters': {            'reason': reason,            'employee_name': employee_name,            'start_date': start_date_str,            'end_date': end_date_str,            'status': status,        },        'show_subordinates': show_subordinates, # Передаем в шаблон        'show_my': show_my, # Передаем в шаблон        'current_filter': filter_type # Передаем в шаблон    }    return render(request, 'overtime_app/export_requests.html', context)@login_requireddef export_requests_word(request):    """    Экспортирует заявки подчинённых в документ Word по шаблону служебной записки.    Использует фильтры: start_date, end_date, employee_name, status, reason.    Группирует строки по сотруднику. Вставляет уникальные причины (reason).    Использует ручную должность (job_title_manual) и подразделение (department).    Разбивает заявки по дням, равномерно распределяя часы.    """    employee = Employee.objects.get(email=request.user.email)    # Только менеджеры могут экспортировать заявки подчинённых    if not employee.is_manager:        messages.error(request, 'У вас нет прав для экспорта заявок подчинённых.')        return redirect('overtime_app:dashboard')    # --- Применение фильтров ---    # Получаем фильтры из URL-параметров    employee_name_filter = request.GET.get('employee_name')    start_date_str = request.GET.get('start_date')    end_date_str = request.GET.get('end_date')    status_filter = request.GET.get('status')    reason_filter = request.GET.get('reason')    # Начальный queryset - заявки подчинённых    requests = OvertimeRequest.objects.filter(employee__manager1=employee).select_related('employee')    # Применяем фильтр по имени сотрудника (если указан)    if employee_name_filter:        requests = requests.filter(employee__full_name__icontains=employee_name_filter)    # Применяем фильтр по статусу (если указан)    if status_filter:        requests = requests.filter(status=status_filter)    # Применяем фильтр по причине (если указана)    if reason_filter:        requests = requests.filter(reason=reason_filter)    # Применяем фильтр по дате (если указаны)    start_date = None    end_date = None    if start_date_str:        try:            start_date = datetime.strptime(start_date_str, '%Y-%m-%d').date()        except ValueError:            messages.error(request, 'Неверный формат даты начала.')            return redirect('overtime_app:export_requests')    if end_date_str:        try:            end_date = datetime.strptime(end_date_str, '%Y-%m-%d').date()        except ValueError:            messages.error(request, 'Неверный формат даты окончания.')            return redirect('overtime_app:export_requests')    # Проверяем, что даты указаны    if not start_date or not end_date:        messages.error(request, 'Для выгрузки по шаблону необходимо указать начальную и конечную даты.')        return redirect('overtime_app:export_requests')    # Проверяем, что даты находятся в одном календарном месяце и году    if start_date.month != end_date.month or start_date.year != end_date.year:        messages.error(request, 'Даты должны быть в пределах одного календарного месяца и года.')        return redirect('overtime_app:export_requests')    # Применяем фильтр по датам: пересечение интервалов    # Заявка подходит, если: (start_req <= end_filter AND end_req >= start_filter)    requests = requests.filter(        start_datetime__date__lte=end_date, # Заявка начинается до или в конечную дату фильтра        end_datetime__date__gte=start_date  # Заявка заканчивается после или в начальную дату фильтра    )    if not requests.exists():        messages.warning(request, 'Нет заявок подчинённых по указанным фильтрам для выгрузки.')        return redirect('overtime_app:export_requests') # Вернуться на страницу фильтров    # --- Вычисления для документа ---    # Месяц и год из фильтра    # Словарь для русских названий месяцев    month_names_rus = {        1: 'январе', 2: 'феврале', 3: 'марте', 4: 'апреле', 5: 'мае', 6: 'июне',        7: 'июле', 8: 'августе', 9: 'сентябре', 10: 'октябре', 11: 'ноябре', 12: 'декабре'    }    month_name_rus = month_names_rus.get(start_date.month, 'месяце')    year = start_date.year    # Уникальные ПРИЧИНЫ (reason) из заявок (используем отображаемое имя)    unique_reasons = set(req.get_reason_display() for req in requests)    reasons_text = ', '.join(unique_reasons) if unique_reasons else 'Не указано'    # --- Генерация документа Word ---    doc = Document()    # Добавляем параграф "Генеральному директору"    p_director = doc.add_paragraph()    p_director.add_run('Генеральному директору\n').bold = True    p_director.add_run('ООО « АТОН»\n').bold = True    p_director.add_run('Звездочкину А.М.\n').bold = True    p_director.alignment = 2 # 2 = RIGHT    # Добавляем отступ    doc.add_paragraph()    # Добавляем основной текст    p_main = doc.add_paragraph()    p_main.add_run('СЛУЖЕБНАЯ ЗАПИСКА\n').bold = True    p_main.alignment = 1 # 1 = CENTER    # Вставляем месяц и год в основной текст    main_text_run = p_main.add_run(f'В связи с производственной необходимостью прошу привлечь к работе в выходные дни в ')    main_text_run = p_main.add_run(f'{month_name_rus} ').bold = True # Жирный месяц    main_text_run = p_main.add_run(f'{year} г. следующих работников:\n') # Год    # Добавляем таблицу    # № | ФИО | Должность, подразделение | Дата работы | Количество рабочих часов | Ознакомлен, с выходом согласен    table = doc.add_table(rows=1, cols=6)    table.style = 'Table Grid'    # Заголовки таблицы    hdr_cells = table.rows[0].cells    hdr_cells[0].text = '№'    hdr_cells[1].text = 'ФИО'    hdr_cells[2].text = 'Должность, подразделение'    hdr_cells[3].text = 'Дата работы'    hdr_cells[4].text = 'Количество рабочих часов'    hdr_cells[5].text = 'Ознакомлен, с выходом согласен'    # Группировка заявок по сотруднику    grouped_requests = defaultdict(list)    for req in requests:        grouped_requests[req.employee].append(req)    row_counter = 1    for emp, emp_requests in grouped_requests.items():        # Сортируем заявки сотрудника по дате начала        sorted_emp_requests = sorted(emp_requests, key=lambda x: x.start_datetime)        # Создаем строку для сотрудника        row_cells = table.add_row().cells        row_cells[0].text = str(row_counter)        row_cells[1].text = emp.full_name or "Не указано"        # Используем ручную должность (job_title_manual) и подразделение (department)        job_title_text = emp.job_title_manual or "Должность не указана" # Резервное значение        dept_text = emp.department if emp.department else "Подразделение не указано"        row_cells[2].text = f"{job_title_text}, {dept_text}"        # --- НОВАЯ ЛОГИКА: Разбиение заявок по дням ---        all_dates = []        all_hours = []        for req in sorted_emp_requests:            # Определяем дни, в которые происходила работа            current_day = req.start_datetime.date()            end_day = req.end_datetime.date()            # Вычисляем количество дней (включая обе даты)            num_days = (end_day - current_day).days + 1            # Вычисляем часы в день            hours_per_day = req.hours / num_days if num_days > 0 else 0            # Проходим по каждому дню            for i in range(num_days):                day = current_day + timedelta(days=i)                all_dates.append(day.strftime('%d.%m.%Y'))                # Округляем часы до 2 знаков после запятой для читаемости                all_hours.append(f"{hours_per_day:.2f}")        # Объединяем даты и часы в строки для ячеек        dates_str = "\n".join(all_dates)        hours_str = "\n".join(all_hours)        row_cells[3].text = dates_str        row_cells[4].text = hours_str        # Ячейка "Ознакомлен" - оставляем пустой для заполнения вручную        row_cells[5].text = ""        row_counter += 1 # Увеличиваем счётчик строки    # Добавляем пустой параграф (отступ)    doc.add_paragraph()    # Добавляем текст "Работа, выполненная в этот день:" и причины (reason)    p_justification = doc.add_paragraph()    p_justification.add_run('Работа, выполненная в этот день: ').bold = True    p_justification.add_run(reasons_text)    # Добавляем пустой параграф (отступ)    doc.add_paragraph()    # Добавляем текст про компенсацию    p_compensation = doc.add_paragraph()    p_compensation.add_run('Прошу произвести компенсацию в ')    p_compensation.add_run('денежной форме ').bold = True # Жирная "денежной форме"    p_compensation.add_run('/ в виде предоставления другого дня отдыха.')    # Добавляем пустой параграф (отступ)    doc.add_paragraph()    # Добавляем подпись и ФИО    p_signature = doc.add_paragraph()    p_signature.add_run('_________________/').bold = True    p_signature.add_run(f'{employee.full_name} /').bold = True    p_signature.alignment = 2 # RIGHT    # --- Отправка файла ---    response = HttpResponse(content_type='application/vnd.openxmlformats-officedocument.wordprocessingml.document')    response['Content-Disposition'] = f'attachment; filename="Sluzhebka_podchinyonie_{month_name_rus}_{year}_{datetime.now().strftime("%Y%m%d_%H%M%S")}.docx"'    doc.save(response)    return responsedef portal_login(request):    if request.method == 'POST':        username = request.POST.get('username')        password = request.POST.get('password')        user = authenticate(request, username=username, password=password)        if user is not None:            login(request, user)            return redirect('overtime_app:dashboard')        else:            messages.error(request, 'Неверное имя пользователя или пароль')    return render(request, 'overtime_app/login.html')@login_requireddef dashboard(request):    try:        employee = Employee.objects.get(email=request.user.email)    except Employee.DoesNotExist:        # Если профиль сотрудника не найден, отправляем на главную страницу        messages.error(request, 'Ваш профиль сотрудника не найден. Обратитесь к администратору.')        return redirect('home') # 'home' существует в основном urls.py    except Employee.MultipleObjectsReturned:        messages.error(request, 'Ошибка: найдено несколько сотрудников с этим email. Обратитесь к администратору.')        return redirect('home')    # Проверим, является ли сотрудник руководителем    is_manager = employee.is_manager    my_requests = OvertimeRequest.objects.filter(employee=employee).order_by('-created_at')    if is_manager:        # Заявки подчинённых, отсортированные: сначала "На согласовании", потом остальные        subordinates_requests = OvertimeRequest.objects.filter(            employee__manager1=employee        ).annotate(            custom_order=Case(                When(status='pending', then=Value(0)),                default=Value(1),                output_field=IntegerField()            )        ).order_by('custom_order', '-created_at')    else:        subordinates_requests = []    context = {        'employee': employee,        'my_requests': my_requests,        'subordinates_requests': subordinates_requests,        'is_manager': is_manager,    }    return render(request, 'overtime_app/dashboard.html', context)@login_requireddef create_request(request):    user = request.user    current_user_employee = Employee.objects.filter(email=user.email).first()    if request.method == 'POST':        form = OvertimeRequestForm(            request.POST,            request.FILES,            current_user_employee=current_user_employee        )        if form.is_valid():            overtime_request = form.save(commit=False)            # Определяем сотрудника, для которого создается заявка            subordinate = form.cleaned_data.get('subordinate_employee')            if subordinate and current_user_employee.is_manager:                # Руководитель создает заявку за подчинённого                overtime_request.employee = subordinate            else:                # Сотрудник создает заявку за себя                overtime_request.employee = current_user_employee            overtime_request.save()            # --- НОВАЯ ЛОГИКА: Отправка уведомления руководителю с токенами ---            manager = overtime_request.employee.manager1            if manager and manager.email:                try:                    # Генерируем уникальный токен                    token_str = secrets.token_urlsafe(32) # 32 символа - это 256 бит энтропии                    # Определяем время истечения токена (например, 7 дней)                    expires_at = timezone.now() + timedelta(days=7)                    # Сохраняем токен в базе данных                    ApprovalToken.objects.create(                        request=overtime_request,                        approver=manager,                        token=token_str,                        expires_at=expires_at,                        used=False                    )                    # Формируем абсолютные URL для согласования и отклонения с токеном                    approve_url = request.build_absolute_uri(                        reverse('overtime_app:approve_via_email', kwargs={'req_id': overtime_request.id}) +                        f'?token={token_str}&decision=approved'                    )                    reject_url = request.build_absolute_uri(                        reverse('overtime_app:approve_via_email', kwargs={'req_id': overtime_request.id}) +                        f'?token={token_str}&decision=rejected'                    )                    # Ссылка на дашборд как альтернатива                    dashboard_url = request.build_absolute_uri(reverse('overtime_app:dashboard'))                    subject = f'Новая заявка на переработку от {overtime_request.employee.full_name} (#{overtime_request.id})'                    text_content = f"""                    У вас новая заявка на переработку от {overtime_request.employee.full_name} (ID: #{overtime_request.id}).                    Детали заявки:                    - Сотрудник: {overtime_request.employee.full_name}                    - Дата и время начала: {overtime_request.start_datetime.strftime('%d.%m.%Y %H:%M')}                    - Дата и время окончания: {overtime_request.end_datetime.strftime('%d.%m.%Y %H:%M')}                    - Количество часов: {overtime_request.hours:.2f}                    - Причина: {overtime_request.get_reason_display()}                    - Обоснование: {overtime_request.justification or "Не указано"}                    Перейти на портал для просмотра заявки: {dashboard_url}                    Быстрые действия:                    - Согласовать: {approve_url}                    - Не согласовать: {reject_url}                    """                    html_content = f"""                    <html>                    <body>                        <h2>Новая заявка на переработку #{overtime_request.id}</h2>                        <p>У вас новая заявка на переработку от <strong>{overtime_request.employee.full_name}</strong>.</p>                        <h3>Детали заявки:</h3>                        <ul>                            <li><strong>Сотрудник:</strong> {overtime_request.employee.full_name}</li>                            <li><strong>Дата и время начала:</strong> {overtime_request.start_datetime.strftime('%d.%m.%Y %H:%M')}</li>                            <li><strong>Дата и время окончания:</strong> {overtime_request.end_datetime.strftime('%d.%m.%Y %H:%M')}</li>                            <li><strong>Количество часов:</strong> {overtime_request.hours:.2f}</li>                            <li><strong>Причина:</strong> {overtime_request.get_reason_display()}</li>                            <li><strong>Обоснование:</strong> {overtime_request.justification or "Не указано"}</li>                        </ul>                        <p>                            <a href="{dashboard_url}" style="padding: 10px 15px; text-decoration: none; color: white; background-color: #007bff; border-radius: 5px; margin-right: 10px;">Перейти к заявке</a>                        </p>                        <p><strong>Быстрые действия:</strong></p>                        <p>                            <a href="{approve_url}" style="padding: 10px 15px; text-decoration: none; color: white; background-color: #28a745; border-radius: 5px; margin-right: 10px;">Согласовать</a>                            <a href="{reject_url}" style="padding: 10px 15px; text-decoration: none; color: white; background-color: #dc3545; border-radius: 5px;">Не согласовать</a>                        </p>                    </body>                    </html>                    """                    msg = EmailMultiAlternatives(                        subject=subject,                        body=text_content, # Текстовая версия                        from_email=None, # Использует DEFAULT_FROM_EMAIL                        to=[manager.email],                    )                    msg.attach_alternative(html_content, "text/html")                    msg.send()                    # Опционально: добавить сообщение об успешной отправке                    # messages.success(request, f'Уведомление с кнопками отправлено руководителю {manager.full_name} ({manager.email}).')                except Exception as e:                    import logging                    logger = logging.getLogger(__name__)                    logger.error(f"Ошибка отправки email уведомления руководителю {manager.email} о заявке #{overtime_request.id}: {e}")                    # Опционально: сообщить пользователю об ошибке                    # messages.warning(request, f'Уведомление руководителю не было отправлено из-за ошибки: {e}')            # --- КОНЕЦ НОВОЙ ЛОГИКИ ---            messages.success(request, 'Заявка успешно создана.')            return redirect('overtime_app:dashboard')        else:            # Форма не валидна, оставляем пользователя на той же странице с ошибками            pass # Django автоматически покажет ошибки в шаблоне    else:        form = OvertimeRequestForm(current_user_employee=current_user_employee)    return render(request, 'overtime_app/create_request.html', {        'form': form,        'is_manager': current_user_employee.is_manager if current_user_employee else False    })@login_requireddef my_requests(request):    try:        employee = Employee.objects.get(email=request.user.email)    except Employee.DoesNotExist:        messages.error(request, 'Ваш профиль сотрудника не найден.')        return redirect('overtime_app:dashboard')    requests = OvertimeRequest.objects.filter(employee=employee).order_by('-created_at')    return render(request, 'overtime_app/my_requests.html', {'requests': requests})def home(request):    return render(request, 'overtime_app/home.html')@login_requireddef view_requests(request):    if not request.user.is_authenticated:        return redirect('portal_login')    try:        employee = Employee.objects.get(email=request.user.email)    except Employee.DoesNotExist:        messages.error(request, 'Ваш профиль сотрудника не найден.')        return redirect('overtime_app:dashboard')    # Только руководитель может видеть заявки подчинённых    # Проверяем, есть ли у сотрудника подчиненные    is_manager = employee.is_manager    if not is_manager:        messages.error(request, 'У вас нет прав для просмотра заявок подчинённых')        return redirect('overtime_app:dashboard')    requests = OvertimeRequest.objects.filter(        employee__manager1=employee    ).order_by('-created_at')    return render(request, 'overtime_app/view_requests.html', {'requests': requests})@login_requireddef serve_text_file(request, filename):    """    Отдаёт файл из MEDIA_ROOT/overtime_attachments/ с корректной кодировкой UTF-8.    Если файл не текстовый — отдаёт его как бинарный.    """    file_path = os.path.join(settings.MEDIA_ROOT, 'overtime_attachments', filename)    if not os.path.exists(file_path):        raise Http404("Файл не найден")    content_type, _ = mimetypes.guess_type(file_path)    # Текстовые файлы читаем как UTF-8    if content_type and content_type.startswith("text/"):        try:            with open(file_path, "r", encoding="utf-8") as f:                content = f.read()        except UnicodeDecodeError:            # если файл не в utf-8, можно fallback            with open(file_path, "r", encoding="cp1251", errors="replace") as f:                content = f.read()        return HttpResponse(content, content_type=f"{content_type}; charset=utf-8")    # Остальные файлы — как бинарные (например, .xlsx, .pdf)    return FileResponse(open(file_path, "rb"), content_type=content_type or "application/octet-stream")@login_required@require_http_methods(["GET"])def get_request_data(request, request_id):    # Получаем заявку    req = get_object_or_404(OvertimeRequest, id=request_id)    # Получаем текущего пользователя (предполагаем, что у User есть связь с Employee)    try:        current_employee = Employee.objects.get(email=request.user.email)    except Employee.DoesNotExist:        # Если профиль сотрудника не найден, возвращаем ошибку        return JsonResponse({'error': 'Профиль сотрудника не найден'}, status=403)    # Проверяем права доступа:    # 1. Владелец заявки (создатель)    is_owner = (req.employee == current_employee)    # 2. Менеджер подчинённого (может просматривать заявки любого статуса)    is_manager_of_owner = (req.employee.manager1 == current_employee)    if not (is_owner or is_manager_of_owner):        return JsonResponse({'error': 'Нет прав доступа для просмотра данных заявки'}, status=403)    # Подготовка данных для JSON    data = {        'id': req.id,        'start_datetime': req.start_datetime.isoformat() if req.start_datetime else None,        'end_datetime': req.end_datetime.isoformat() if req.end_datetime else None,        'reason': req.reason,        'justification': req.justification,        # Добавляем имя текущего файла, если он есть        'current_attachment_name': os.path.basename(req.attachment.name) if req.attachment else None,        # 'current_original_filename': req.original_filename if hasattr(req, 'original_filename') else None, # Опционально        # Добавляем текущий статус        'status': req.status,    }    return JsonResponse(data)@login_required@require_http_methods(["POST"])def update_request(request, request_id):    # Получаем заявку    req = get_object_or_404(OvertimeRequest, id=request_id)    # Получаем текущего пользователя (предполагаем, что у User есть связь с Employee)    try:        current_employee = Employee.objects.get(email=request.user.email)    except Employee.DoesNotExist:        return JsonResponse({'error': 'Профиль сотрудника не найден'}, status=403)    # Проверяем права доступа на обновление:    # 1. Владелец заявки (создатель) - может редактировать только 'pending'    is_owner = (req.employee == current_employee)    # 2. Менеджер подчинённого (может редактировать любые статусы и менять статус)    is_manager_of_owner = (req.employee.manager1 == current_employee)    if not (is_owner or is_manager_of_owner):        return JsonResponse({'error': 'Нет прав доступа для обновления заявки'}, status=403)    # Владелец может редактировать только заявки в статусе 'pending'    if is_owner and req.status != 'pending':        return JsonResponse({'error': 'Вы можете редактировать заявку только в статусе "На согласовании".'}, status=403)    # Получаем данные из формы    start_datetime_str = request.POST.get('start_datetime')    end_datetime_str = request.POST.get('end_datetime')    reason = request.POST.get('reason')    justification = request.POST.get('justification')    attachment = request.FILES.get('attachment') # файл может быть необязательным    new_status = request.POST.get('status') # Новый статус (только для менеджера)    # Проверка изменения статуса менеджером    if new_status and is_manager_of_owner:        # Проверяем, что новый статус допустим        valid_statuses = [choice[0] for choice in OvertimeRequest.STATUS_CHOICES]        if new_status not in valid_statuses:            return JsonResponse({'error': 'Недопустимый статус.'}, status=400)        # Обновляем статус, если он передан и пользователь - менеджер        req.status = new_status    elif new_status and is_owner:        # Владелец не может изменить статус        return JsonResponse({'error': 'Вы не можете изменить статус заявки.'}, status=403)    # Валидация и обновление (упрощённо, лучше использовать ModelForm)    errors = []    if start_datetime_str and end_datetime_str: # Оба поля присутствуют, проверяем        try:            start_datetime = timezone.datetime.fromisoformat(start_datetime_str.replace('Z', '+00:00'))            end_datetime = timezone.datetime.fromisoformat(end_datetime_str.replace('Z', '+00:00'))            # Проверка, что окончание позже начала            if start_datetime >= end_datetime:                errors.append("Время окончания должно быть позже времени начала.")        except ValueError:            return JsonResponse({'error': 'Неверный формат даты или времени.'}, status=400)    elif start_datetime_str or end_datetime_str: # Только одно из них присутствует        errors.append("Необходимо указать оба поля: дату и время начала и окончания.")    if errors:        return JsonResponse({'error': '; '.join(errors)}, status=400)    # Обновляем поля, если они были переданы    if start_datetime_str and end_datetime_str:        req.start_datetime = start_datetime        req.end_datetime = end_datetime    if reason:        req.reason = reason    if justification:        req.justification = justification    if attachment:        req.attachment = attachment    req.save()    # Возвращаем успешный ответ    return JsonResponse({'success': True, 'message': 'Заявка успешно обновлена.'})