from django.shortcuts import render, get_object_or_404, redirectfrom django.core.mail import send_mail, EmailMultiAlternativesfrom django.contrib.auth.decorators import login_requiredfrom django.contrib.auth import login, authenticatefrom django.http import HttpResponsefrom docx import Documentfrom django.urls import reversefrom datetime import datetimefrom django.utils import timezonefrom .models import OvertimeRequest, Employee, ApprovalLog, Position, ApprovalTokenfrom .forms import OvertimeRequestForm, EmployeeProfileFormfrom django.db.models import Case, When, Value, IntegerFieldfrom django.contrib.auth.views import LogoutView as DjangoLogoutViewfrom django.http import JsonResponsefrom django.contrib import messagesfrom django.shortcuts import render, redirectfrom django.contrib.auth.models import Userfrom .forms import ResetPasswordFormdef reset_password(request):    if request.method == 'POST':        form = ResetPasswordForm(request.POST)        if form.is_valid():            username = form.cleaned_data['username']            new_password = form.cleaned_data['new_password1']            user = User.objects.get(username=username)            user.set_password(new_password)            user.save()            messages.success(request, 'Пароль успешно изменён. Теперь вы можете войти.')            return redirect('portal_login')    else:        form = ResetPasswordForm()    return render(request, 'overtime_app/reset_password.html', {'form': form})class LogoutView(DjangoLogoutView):    http_method_names = ['get', 'post']def request_access(request):    if request.method == 'POST':        # Отправить письмо администратору        try:            send_mail(                subject='Запрос доступа к порталу',                message=f'Пользователь с IP-адреса {request.META.get("REMOTE_ADDR")} запросил доступ к порталу.',                from_email=None,  # Использует DEFAULT_FROM_EMAIL                recipient_list=['ServiseDesk@aton.ru'],  # email техподдержки            )            return JsonResponse({'success': True})        except Exception as e:            print(f'Ошибка отправки письма: {e}')            return JsonResponse({'success': False})    return JsonResponse({'success': False})# Исправленная функция process_approvaldef process_approval(req, approver, decision, comment):    """    Обрабатывает решение по заявке: создает запись в логе, обновляет статус, отправляет уведомление.    """    # Создаем запись согласования    ApprovalLog.objects.create(        request=req,        approver=approver,        decision=decision,        comment=comment    )    # Обновляем статус    if decision == 'approved':        req.status = 'approved'    elif decision == 'rejected':        req.status = 'rejected'    req.save()    # Отправляем уведомление сотруднику, если email действителен    if req.employee.email:        try:            # Подробное сообщение для сотрудника            subject = f'Заявка #{req.id} на переработку {req.get_status_display()}'            text_content = f"""            Ваша заявка на переработку (#{req.id}) была {req.get_status_display()}.            Детали:            - Сотрудник: {req.employee.full_name}            - Начало: {req.start_datetime.strftime('%d.%m.%Y %H:%M')}            - Окончание: {req.end_datetime.strftime('%d.%m.%Y %H:%M')}            - Количество часов: {req.hours:.2f}            - Причина: {req.get_reason_display()}            - Обоснование: {req.justification or "Не указано"}            - Решение принято: {approver.full_name}            - Комментарий: {comment if comment else "Не предоставлен"}            """            html_content = f"""            <html>            <body>                <h2>Заявка на переработку #{req.id}</h2>                <p><strong>Статус:</strong> {req.get_status_display()}</p>                <h3>Детали:</h3>                <ul>                    <li><strong>Сотрудник:</strong> {req.employee.full_name}</li>                    <li><strong>Начало:</strong> {req.start_datetime.strftime('%d.%m.%Y %H:%M')}</li>                    <li><strong>Окончание:</strong> {req.end_datetime.strftime('%d.%m.%Y %H:%M')}</li>                    <li><strong>Количество часов:</strong> {req.hours:.2f}</li>                    <li><strong>Причина:</strong> {req.get_reason_display()}</li>                    <li><strong>Обоснование:</strong> {req.justification or "Не указано"}</li>                    <li><strong>Решение принято:</strong> {approver.full_name}</li>                    <li><strong>Комментарий:</strong> {comment if comment else "Не предоставлен"}</li>                </ul>            </body>            </html>            """            msg = EmailMultiAlternatives(                subject=subject,                body=text_content,  # Текстовая версия на случай, если HTML недоступен                from_email=None,  # Использует DEFAULT_FROM_EMAIL                to=[req.employee.email],            )            msg.attach_alternative(html_content, "text/html")            msg.send()        except Exception as e:            # Логируем ошибку, но не останавливаем выполнение            print(f"Ошибка отправки email на {req.employee.email}: {e}")    # Помечаем токен как использованный    try:        token_obj = ApprovalToken.objects.get(request=req, approver=approver, used=False)        token_obj.used = True        token_obj.save()    except ApprovalToken.DoesNotExist:        pass@login_requireddef change_status(request, req_id):    """    Позволяет руководителю изменить статус заявки на "Согласовано" или "Не согласовано".    """    if request.method != 'POST':        return redirect('overtime_app:view_requests')    req = get_object_or_404(OvertimeRequest, id=req_id)    # Получаем текущего пользователя (руководителя)    try:        approver = Employee.objects.get(email=request.user.email)    except Employee.DoesNotExist:        messages.error(request, 'Ваш профиль сотрудника не найден.')        return redirect('overtime_app:dashboard')    # Проверяем, является ли текущий пользователь правильным согласующим    if req.employee.manager1 != approver:        messages.error(request, 'У вас нет прав для согласования этой заявки.')        return redirect('overtime_app:view_requests')    decision = request.POST.get('decision')    if decision not in ['approved', 'rejected']:        messages.error(request, 'Неверное действие.')        return redirect('overtime_app:view_requests')    comment = request.POST.get('comment', '')    # Используем общую функцию обработки    process_approval(req, approver, decision, comment)    messages.success(request, f'Заявка #{req.id} была {"согласована" if decision == "approved" else "отклонена"}.')    return redirect('overtime_app:view_requests')# Исправленная функция approve_via_email (проверка токена и завершение логики)@login_requireddef approve_via_email(request, req_id):    """    Обрабатывает согласование/отклонение заявки через email-ссылку.    """    req = get_object_or_404(OvertimeRequest, id=req_id)    token = request.GET.get('token')    decision = request.GET.get('decision')    if decision not in ['approved', 'rejected']:  # Убрали 'rework'        messages.error(request, 'Неверное действие.')        return redirect('overtime_app:dashboard')    # Проверка токена    try:        token_obj = ApprovalToken.objects.get(token=token, request=req)        # Проверка валидности токена        if token_obj.used or token_obj.expires_at < timezone.now():            messages.error(request, 'Ссылка недействительна или истекла.')            return redirect('overtime_app:dashboard')    except ApprovalToken.DoesNotExist:        messages.error(request, 'Неверная ссылка.')        return redirect('overtime_app:dashboard')    # Получаем текущего пользователя (руководителя)    try:        approver = Employee.objects.get(email=request.user.email)    except Employee.DoesNotExist:        messages.error(request, 'Ваш профиль сотрудника не найден.')        return redirect('overtime_app:dashboard')    # Проверяем, является ли текущий пользователь правильным согласующим    if token_obj.approver != approver:        messages.error(request, 'Недостаточно прав для согласования.')        return redirect('overtime_app:dashboard')    # Обработка решения    comment = request.GET.get('comment', '')    process_approval(req, approver, decision, comment)    messages.success(request, f'Заявка #{req.id} была {"согласована" if decision == "approved" else "отклонена"}.')  # Убрали "на доработку"    return redirect('overtime_app:dashboard')# Исправленная функция approve_request - теперь обрабатывает POST-запросы из веб-интерфейса@login_requireddef approve_request(request, req_id):    """    Обрабатывает согласование/отклонение заявки через веб-интерфейс.    """    if request.method != 'POST':        return redirect('overtime_app:dashboard')    req = get_object_or_404(OvertimeRequest, id=req_id)    # Получаем текущего пользователя (руководителя)    try:        approver = Employee.objects.get(email=request.user.email)    except Employee.DoesNotExist:        messages.error(request, 'Ваш профиль сотрудника не найден.')        return redirect('overtime_app:dashboard')    # Проверяем, является ли текущий пользователь правильным согласующим    # (например, manager1). Можно расширить логику для manager2.    if req.employee.manager1 != approver:        messages.error(request, 'У вас нет прав для согласования этой заявки.')        return redirect('overtime_app:dashboard')    decision = request.POST.get('decision')    if decision not in ['approved', 'rejected']:  # Убрали 'rework'        messages.error(request, 'Неверное действие.')        return redirect('overtime_app:dashboard')    comment = request.POST.get('comment', '')    # Используем общую функцию обработки    process_approval(req, approver, decision, comment)    messages.success(request, f'Заявка #{req.id} была {"согласована" if decision == "approved" else "отклонена"}.')  # Убрали "на доработку"    return redirect('overtime_app:dashboard')@login_requireddef export_requests_word(request):    """    Экспортирует отфильтрованные заявки в документ Word.    """    employee = Employee.objects.get(email=request.user.email)    is_manager = employee.is_manager    # Определяем фильтр    filter_type = request.GET.get('filter')    # Начальный queryset    if filter_type == 'my':        requests = OvertimeRequest.objects.filter(employee=employee)    elif filter_type == 'subordinates' and is_manager:        requests = OvertimeRequest.objects.filter(employee__manager1=employee)    else:        # По умолчанию — как раньше        if is_manager:            requests = OvertimeRequest.objects.filter(employee__manager1=employee)        else:            requests = OvertimeRequest.objects.filter(employee=employee)    # Применяем фильтры из формы    reason = request.GET.get('reason')    employee_name = request.GET.get('employee_name')    start_date = request.GET.get('start_date')    end_date = request.GET.get('end_date')    status = request.GET.get('status')    if reason:        requests = requests.filter(reason=reason)    if employee_name and is_manager:        requests = requests.filter(employee__full_name__icontains=employee_name)    if start_date:        requests = requests.filter(start_datetime__date__gte=start_date)    if end_date:        requests = requests.filter(end_datetime__date__lte=end_date)    if status:        requests = requests.filter(status=status)    # Создаем Word документ    doc = Document()    doc.add_heading('Заявки на переработку', 0)    # Добавляем таблицу    table = doc.add_table(rows=1, cols=9)    table.style = 'Table Grid'    # Заголовки    hdr_cells = table.rows[0].cells    hdr_cells[0].text = '№'    hdr_cells[1].text = 'Сотрудник'    hdr_cells[2].text = 'Отдел'    hdr_cells[3].text = 'Начало'    hdr_cells[4].text = 'Окончание'    hdr_cells[5].text = 'Часы'    hdr_cells[6].text = 'Причина'    hdr_cells[7].text = 'Обоснование'    hdr_cells[8].text = 'Статус'    # Данные    for req in requests:        row_cells = table.add_row().cells        row_cells[0].text = str(req.id)        row_cells[1].text = req.employee.full_name or "Не указано"        row_cells[2].text = req.employee.department or "Не указан"        row_cells[3].text = req.start_datetime.strftime('%d.%m.%Y %H:%M')        row_cells[4].text = req.end_datetime.strftime('%d.%m.%Y %H:%M')        row_cells[5].text = f"{req.hours:.2f}"        row_cells[6].text = req.get_reason_display()        row_cells[7].text = req.justification or "Не указано"        row_cells[8].text = req.get_status_display()    # Отправляем файл    response = HttpResponse(content_type='application/vnd.openxmlformats-officedocument.wordprocessingml.document')    response['Content-Disposition'] = f'attachment; filename="requests_{datetime.now().strftime("%Y%m%d_%H%M%S")}.docx"'    doc.save(response)    return response@login_requireddef export_requests(request):    """    Отображает страницу с формой фильтрации и списком заявок для экспорта.    """    employee = Employee.objects.get(email=request.user.email)    is_manager = employee.is_manager    # Определяем фильтр    filter_type = request.GET.get('filter')    # Начальный queryset    if filter_type == 'my':        requests = OvertimeRequest.objects.filter(employee=employee)    elif filter_type == 'subordinates' and is_manager:        requests = OvertimeRequest.objects.filter(employee__manager1=employee)    else:        # По умолчанию — как раньше        if is_manager:            requests = OvertimeRequest.objects.filter(employee__manager1=employee)        else:            requests = OvertimeRequest.objects.filter(employee=employee)    # Применяем фильтры из формы    reason = request.GET.get('reason')    employee_name = request.GET.get('employee_name')    start_date = request.GET.get('start_date')    end_date = request.GET.get('end_date')    status = request.GET.get('status')    if reason:        requests = requests.filter(reason=reason)    if employee_name and is_manager:        requests = requests.filter(employee__full_name__icontains=employee_name)    if start_date:        requests = requests.filter(start_datetime__date__gte=start_date)    if end_date:        requests = requests.filter(end_datetime__date__lte=end_date)    if status:        requests = requests.filter(status=status)    # Для отображения формы фильтров    reasons = OvertimeRequest.REASON_CHOICES    statuses = OvertimeRequest.STATUS_CHOICES    if is_manager:        employees = Employee.objects.filter(manager1=employee)    else:        employees = Employee.objects.none()    context = {        'requests': requests,        'reasons': reasons,        'statuses': statuses,        'employees': employees,        'is_manager': is_manager,        'filters': {            'reason': reason,            'employee_name': employee_name,            'start_date': start_date,            'end_date': end_date,            'status': status,        }    }    return render(request, 'overtime_app/export_requests.html', context)def portal_login(request):    if request.method == 'POST':        username = request.POST.get('username')        password = request.POST.get('password')        user = authenticate(request, username=username, password=password)        if user is not None:            login(request, user)            return redirect('overtime_app:dashboard')        else:            messages.error(request, 'Неверное имя пользователя или пароль')    return render(request, 'overtime_app/login.html')@login_requireddef dashboard(request):    try:        employee = Employee.objects.get(email=request.user.email)    except Employee.DoesNotExist:        # Если профиль сотрудника не найден, отправляем на главную страницу        messages.error(request, 'Ваш профиль сотрудника не найден. Обратитесь к администратору.')        return redirect('home') # 'home' существует в основном urls.py    except Employee.MultipleObjectsReturned:        messages.error(request, 'Ошибка: найдено несколько сотрудников с этим email. Обратитесь к администратору.')        return redirect('home')    # Проверим, является ли сотрудник руководителем    is_manager = employee.is_manager    my_requests = OvertimeRequest.objects.filter(employee=employee).order_by('-created_at')    if is_manager:        # Заявки подчинённых, отсортированные: сначала "На согласовании", потом остальные        subordinates_requests = OvertimeRequest.objects.filter(            employee__manager1=employee        ).annotate(            custom_order=Case(                When(status='pending', then=Value(0)),                default=Value(1),                output_field=IntegerField()            )        ).order_by('custom_order', '-created_at')    else:        subordinates_requests = []    context = {        'employee': employee,        'my_requests': my_requests,        'subordinates_requests': subordinates_requests,        'is_manager': is_manager,    }    return render(request, 'overtime_app/dashboard.html', context)@login_requireddef create_request(request):    try:        employee = Employee.objects.get(email=request.user.email)    except Employee.DoesNotExist:        messages.error(request, 'Ваш профиль сотрудника не найден.')        return redirect('overtime_app:dashboard')    if request.method == 'POST':        form = OvertimeRequestForm(request.POST)        if form.is_valid():            req = form.save(commit=False)            req.employee = employee            req.status = 'pending' # Устанавливаем статус при создании            req.save()            # Отправить письмо руководителю            manager = req.employee.manager1            if manager and manager.email:                # Создаём токен                token_obj = ApprovalToken.create_token(req, manager)                # Генерируем ссылки                approve_url = request.build_absolute_uri(                    reverse('overtime_app:approve_via_email', args=[req.id]) + f'?token={token_obj.token}&decision=approved'                )                reject_url = request.build_absolute_uri(                    reverse('overtime_app:approve_via_email', args=[req.id]) + f'?token={token_obj.token}&decision=rejected'                )                # --- НОВОЕ: Ссылка на портал ---                portal_link = request.build_absolute_uri(reverse('overtime_app:view_requests')) # Ссылка на список заявок подчинённых                # portal_link = request.build_absolute_uri(reverse('overtime_app:some_detail_view', args=[req.id])) # Альтернатива: ссылка на детали конкретной заявки, если такая страница есть                # --- /НОВОЕ ---                # HTML-письмо (оригинальное содержимое + новая ссылка)                html_content = f"""                <h2>Заявка на переработку #{req.id}</h2>                <p><strong>Сотрудник:</strong> {req.employee.full_name}</p>                <p><strong>Начало:</strong> {req.start_datetime}</p>                <p><strong>Окончание:</strong> {req.end_datetime}</p>                <p><strong>Причина:</strong> {req.get_reason_display()}</p>                <p><strong>Обоснование:</strong> {req.justification}</p>                <h3>Действия:</h3>                <a href="{approve_url}" style="display:inline-block;padding:10px 20px;background:#4CAF50;color:white;text-decoration:none;border-radius:5px;margin:5px;">Согласовано</a>                <a href="{reject_url}" style="display:inline-block;padding:10px 20px;background:#F44336;color:white;text-decoration:none;border-radius:5px;margin:5px;">Не согласовано</a>                <!-- Новая ссылка под кнопками -->                <h3><a href="{portal_link}" style="display:inline-block;padding:10px 20px;background:#2196F3;color:white;text-decoration:none;border-radius:5px;margin:5px;">Перейти к заявкам на портале</a></h3>                """                msg = EmailMultiAlternatives(                    subject=f'Заявка на переработку #{req.id} от {req.employee.full_name}',                    body=f'Заявка #{req.id} ждет вашего согласования. Перейдите по ссылке: {approve_url}\n\nИли посетите портал: {portal_link}',                    from_email=None,                    to=[manager.email],                )                msg.attach_alternative(html_content, "text/html")                msg.send()            messages.success(request, 'Заявка создана и отправлена на согласование.')            return redirect('overtime_app:dashboard')    else:        form = OvertimeRequestForm()    return render(request, 'overtime_app/create_request.html', {'form': form})@login_requireddef my_requests(request):    try:        employee = Employee.objects.get(email=request.user.email)    except Employee.DoesNotExist:        messages.error(request, 'Ваш профиль сотрудника не найден.')        return redirect('overtime_app:dashboard')    requests = OvertimeRequest.objects.filter(employee=employee).order_by('-created_at')    return render(request, 'overtime_app/my_requests.html', {'requests': requests})def home(request):    return render(request, 'overtime_app/home.html')@login_requireddef view_requests(request):    if not request.user.is_authenticated:        return redirect('portal_login')    try:        employee = Employee.objects.get(email=request.user.email)    except Employee.DoesNotExist:        messages.error(request, 'Ваш профиль сотрудника не найден.')        return redirect('overtime_app:dashboard')    # Только руководитель может видеть заявки подчинённых    # Проверяем, есть ли у сотрудника подчиненные    is_manager = employee.is_manager    if not is_manager:        messages.error(request, 'У вас нет прав для просмотра заявок подчинённых')        return redirect('overtime_app:dashboard')    requests = OvertimeRequest.objects.filter(        employee__manager1=employee    ).order_by('-created_at')    return render(request, 'overtime_app/view_requests.html', {'requests': requests})